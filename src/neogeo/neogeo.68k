*
* Neo Geo-specific portions of Galaxian
*

* Neo Geo hardware definitions
.include "regdefs.68k"
.include "pengo.inc"

    OPT_DISABLE_DISPLAY_MASKS=1
    OPT_SKIP_SPLASH=0

* exports

    .global _jp_config
    .global _us_config
    .global _sp_config
    .global IRQ1
    .global IRQ3
    .global DUMMY
    .global TRAP
    .global _user
    .global _player_start
    .global _demo_end
    .global _coin_sound

* osd layer   
    .global osd_enable_vblank_interrupt
    .global osd_ack_vblank_interrupt
    .global osd_disable_vblank_interrupt
    .global osd_small_wait
    .global osd_kick_wdog
    .global osd_r_videoram
    .global osd_w_videoram
    .global osd_r_colorram
    .global osd_w_colorram
    .global osd_read_dipswitches
    .global osd_read_coin
    .global osd_sound_enable
    .global osd_sound_disable
    .global osd_sound_start
    .global osd_sound_stop
    .global osd_sound_mute
    .global osd_sound_unmute
    .global osd_read_high_scores
    .global osd_write_high_scores
    .global osd_debug_hook
    .global osd_break
    
    .global osd_update_sprites
    .global osd_set_bank_selectors
        
* debugging only
    .global osd_debug1
    .global osd_debug2
    .global platform_init
    .global _tile_colour
    .global _tile_scroll
    .global _end_of_ng_code
    .global _end_of_ng_data
    
    .text

TRAP00=TRAP
TRAP01=TRAP
TRAP02=TRAP
TRAP03=TRAP
TRAP04=TRAP
TRAP05=TRAP
TRAP06=TRAP
TRAP07=TRAP
TRAP08=TRAP
TRAP09=TRAP
TRAP10=TRAP
TRAP11=TRAP
TRAP12=TRAP
TRAP13=TRAP
TRAP14=TRAP
TRAP15=TRAP

* Cartridge/CD header
.nolist
.include "header.68k"
.list

    .align 4
_jp_config:
_us_config:
_sp_config:
    .ascii    "PENGO           "
    .word     0xffff
    .word     0xffff
    .byte     0xff
    .byte     0xff
    .byte     0x02                | service mode (off)
    .byte     0x34                | coinage (free play)
    .byte     0x04                | bonus life (7000)
    .byte     0x12                | lives (3)
    .byte     0x02                | cabinet
    .byte     0x00
    .byte     0x00
    .byte     0x00
    .byte     0x00
    .byte     0x00
* item names are 12 characters    
    .ascii    "SERVICE MODE"      | item 6
    .ascii    "OFF         "
    .ascii    "ON          "
    .ascii    "COINAGE     "      | item 7
    .ascii    "1C 1C       "
    .ascii    "2C 1C       "
    .ascii    "1C 2C       "
    .ascii    "FREE PLAY   "
    .ascii    "BONUS LIFE  "      | item 8
    .ascii    "7000        "
    .ascii    "10000       "
    .ascii    "12000       "
    .ascii    "20000       "
    .ascii    "LIVES       "      | item 9
    .ascii    "2           "
    .ascii    "3           "
    .ascii    "CABINET     "      | item 10
    .ascii    "VERTICAL    "
    .ascii    "HORIZONTAL  "

  .align 4
IRQ1:
  move.w  #2, 0x3C000C
  rte
    
  .align 4
IRQ3:
  move.w  #1, 0x3C000C
  rte

DUMMY:
  rte
      
TRAP:
  rte
      
_user:
    moveq     #0,d0
    move.b    (BIOS_USER_REQUEST),d0
    lsl.w     #2,d0
    movea.l   1f(pc,d0.w),a0
    jmp       (a0)
    .align 4
1:  .long     startup_init
    .long     eye_catcher
    .long     demo_game
    .long     title_display

startup_init:
* we're not doing things the NeoGeo way
    jmp       BIOSF_SYSTEM_RETURN

eye_catcher:
* we're not doing things the NeoGeo way
    jmp       BIOSF_SYSTEM_RETURN

demo_game:
    move    #0x2700,sr            | disable interrupts
    lea     0x10F300,sp
    move.b  #2,BIOS_USER_MODE     | tell BIOS we're running the game
    jsr     platform_init         | neo geo-specific init
    jmp     pengo_reset           | pass control to the pengo core

title_display:
* we're not doing things the NeoGeo way
    move.b  BIOS_SELECT_TIMER,d0
    jmp     BIOSF_SYSTEM_RETURN

_player_start:
* we're not doing things the NeoGeo way
    rts
        
_demo_end:
* we're not doing things the NeoGeo way
    rts
        
_coin_sound:
* we're not doing things the NeoGeo way
    rts
        
_vblank:
    btst    #7,BIOS_SYSTEM_MODE
    bne.b   .gamemode
    jmp     BIOSF_SYSTEM_INT1
.gamemode:
    movem.l d0-d7/a0-a6,-(a7)
    KICK_WDOG
    jsr     pengo_irq
    jsr     BIOSF_SYSTEM_IO
.nothing:
    movem.l (a7)+,d0-d7/a0-a6
    move.w  #4,REG_IRQACK
    rte

* d1=delay
osd_small_wait:
    lsl.w   #8,d1
0:  dbf     d1,0b
    move.w  #0,d1
    rte
    
osd_kick_wdog:
    KICK_WDOG
    rts

    .equ    SPRITEX_0,              8
    .equ    SPRITEY_0,              (0x1F0-4)
                                    
    .equ    SCB3_STICKY,            (1<<6)

* NEO GEO FIX LAYER tile allocations
    
    .equ    FG_FIX_BASE,            0x0400
    .equ    FG_ASCII_TRANS_BASE,    0x0500
    .equ    FG_ASCII_OPAQUE_BASE,   0x0600
    
* NEO GEO sprite allocations
* -   0- 31 (unused)
* -  64- 95 (32) foreground tilemap
* -  96-103 (8) Pengo sprites
* - 128-131 (4) visible display masking sprites

    .equ    FGSS,                   64
    .equ    PSSS,                   96
    .equ    DMSS,                   128
                                     
    .equ    FGNS,                   32
    .equ    PSNS,                   8
    .equ    DMNS,                   4

    .equ    BG_TILE_BASE,           0x0200
    .equ    PS_TILE_BASE,           0x0A00
    
platform_init:

    KICK_WDOG
*   acknowledge interrupts
    move.w    #7,REG_IRQACK

* clear fix layer (not used)
    jsr       BIOSF_FIX_CLEAR
    jsr       BIOSF_LSP_1ST

* setup palette(s)
    clr.b     REG_PALBANK0
    lea       _pengo_palette.l,a0
    lea       PALETTES,a1                       | start at palette #0
    move.w    #128-1,d7                         | 128 palettes
1:  moveq     #16-1,d6                          | 16 colours/palette
2:  move.w    (a0)+,(a1)+
    dbf       d6,2b
    dbf       d7,1b
    KICK_WDOG
    move.w    #0x0000,(BACKDROPCOLOR)
    
* setup tilemaps and sprites

    lea       VRAM_RW.l,a0
    move.w    #1,2(a0)                          | VRAM_MOD=1

* clear all sprite tiles & attributes
    move.w    #SCB1,-2(a0)                      | VRAM_ADDR=SCB1
    moveq     #0,d7
    move.w    #448*32-1,d7                      | 448 sprites
1:  move.w    #0,(a0)                           | clear tile
    move.w    #0,(a0)                           | clear palette, attributes
    dbf       d7,1b   
* set all zoom to 1
    move.w    #SCB2,-2(a0)                      | VRAM_ADDR=SCB2
    move.w    #448-1,d7                         | 448 sprites
2:  move.w    #0xFFF,(a0)                       | clear zoom
    dbf       d7,2b   
* set all size to 0 (make inactive)
    move.w    #SCB3,-2(a0)                      | VRAM_ADDR=SCB3
    move.w    #448-1,d7                         | 448 sprites
2:  move.w    #0x0000,(a0)                      | clear size
    dbf       d7,2b   

    KICK_WDOG

.ifeq OPT_DISABLE_BG_LAYER

* background tilemap

*   - shrinking coefficients
    move.w    #(SCB2+FGSS),-2(a0)               | VRAM_ADDR=SCB2
    moveq     #FGNS-1,d7
2:  move.w    #0x077F,(a0)                      | 50% H&V (8x8)
    dbf       d7,2b

*   - vertical position, sticky, size           
    move.w    #(SCB3+FGSS),-2(a0)               | VRAM_ADDR=SCB3
    move.w    #(SPRITEY_0)<<7,d0                | YPOS=0
    ori.w     #33,d0                            | SIZE=33
    moveq     #FGNS-1,d7
3:  move.w    d0,(a0)                           | visible
    dbf       d7,3b   
    
*   - horizontal position
    move.w    #(SCB4+FGSS),-2(a0)               | VRAM_ADDR=SCB4
    moveq     #FGNS-1,d7
    move.w    #(SPRITEX_0+16)<<7,d0              | XPOS=0
5:  move.w    d0,(a0)             
    add.w     #(8<<7),d0                        | next XPOS
    dbf       d7,5b

.endif | OPT_DISABLE_BG_LAYER

.ifeq OPT_DISABLE_DISPLAY_MASKS

* display masking sprites

* - tiles and palettes
    move.w    #(SCB1+DMSS)*64,-2(a0)            | VRAM_ADDR=SCB1
    moveq     #DMNS-1,d6                        | 2 sprites
1:  moveq     #32-1,d7
    move.w    #BG_TILE_BASE,d0                  | tile code from BG
2:  move.w    d0,(a0)                           | TILE
    addq.w    #1,d0                             | this is for debugging
* change the palette for debugging these sprites
    move.w    #(1<<8),(a0)                      | PALETTE (black on black)
    dbf       d7,2b
    dbf       d6,1b

*   - vertical position, sticky, size           
    move.w    #(SCB3+DMSS),-2(a0)               | VRAM_ADDR=SCB3
    moveq     #2-1,d7                           | top,bottom
3:  moveq     #DMNS/2-1,d6                      | #sprites
    move.w    #SPRITEY_0<<7,d0                  | YPOS=0
    ori.w     #33,d0                            | SIZE
4:  move.w    d0,(a0)                           | SCB3 data
    ori.w     #SCB3_STICKY,d0
    dbf       d6,4b
    dbf       d7,3b

*   - horizontal position
    move.w    #(SCB4+DMSS),-2(a0)               | VRAM_ADDR=SCB4
    move.w    #SPRITEX_0<<7,d0                  | X POSITION (bottom)
    move.w    d0,(a0)
    move.w    #(SCB4+DMSS+DMNS/2),-2(a0)        | VRAM_ADDR=SCB4
    move.w    #(SPRITEX_0+17*16)<<7,d0          | X POSITION (top)
    move.w    d0,(a0)

.endif | OPT_DISABLE_DISPLAY_MASKS

    * read cabinet H/V setting
    lea       BIOS_GAME_DIP,a0
    move.b    (10,a0),d0                         | cabinet (H/V)
    move.b    d0,(_cabinet)

    * fix for galaxian coin input debounce
    move.b    #0,(_coin_pulse_cnt)
    
    * generate lookup table for fg offset
    lea       fg_offset_lookup_tbl,a0
    moveq     #0,d7
4:  move.w    d7,d3
    and.w     #0x1f,d3                          | row (sprite number indirectly)
    move.w    #31,d2                            | 
    sub.w     d3,d2                             | sprite #
    lsl.w     #6,d2                             | d2=sprite offset in SCB1
    move.w    d7,d3
    lsr.w     #5,d3                             | sprite tile #
    not.w     d3                                | reverse column
    and.w     #0x1f,d3                          | column (tile number)
    lsl.w     #1,d3                             | d3=tile offset in SCB1
    add.w     d2,d3                             | combine for SCB1 address
    add.w     #SCB1+(FGSS*64),d3
    move.w    d3,(a0)+                          | store entry
    addq.w    #1,d7
    cmp.w     #0x0400,d7
    blt       4b
    
    lea       snd_playing,a0
    moveq     #0x20-1,d7
8:  clr.b     (a0)+
    dbf       d7,8b
    
* CD hardware only
.ifdef __cd__
    move.b    #0,(REG_DISBLSPR)                 | enable sprites
    move.b    #1,(REG_ENVIDEO)                  | enable video
.endif

.ifeq OPT_SKIP_SPLASH
    clr.b     REG_PALBANK1                      | alt palette bank
    lea       PALETTES,a0
    * palette 0 - transparent/high score colour/black
    move.w    #0x8000,(0,a0)
    move.w    (_pengo_palette+1*32+2),d0
    move.w    d0,(2,a0)
    move.w    #BLACK,(4,a0)
    * palette 1 - transparent/black/white
    lea       (32,a0),a0
    move.w    #0,(0,a0)
    move.w    #BLACK,(2,a0)
    move.w    #WHITE,(4,a0)
    * palette 2 - transparent/solvalou symbol colour/black
    lea       (32,a0),a0
    move.w    #0,(0,a0)
    move.w    (_pengo_palette+2*32+2),d0
    move.w    d0,(2,a0)
    move.w    #BLACK,(4,a0)
    ** show splash screen on fix layer
    lea       VRAM_RW.l,a0
    move.w    #1,(2,a0)                         | VRAM_MOD=1
    lea       splash,a1
    move.w    #FIXMAP+(38*32),d1
    lea       splash_attr,a2
1:  move.w    d1,(-2,a0)                        | VRAM_ADDR
    move.w    #FG_ASCII_OPAQUE_BASE,d0          | tile base
    or.w      (a2)+,d0                          | line attribute
    moveq     #32-1,d6                          | 32 chars per line
    
2:  move.b    (a1)+,d0
    move.w    d0,(a0)                           | VRAM
    dbf       d6,2b                             | do line
    sub.w     #32,d1                            | next line VRAM address
    tst.b     (a1)                              | last line?
    bne.b     1b                                | no, loop
    *
3:  KICK_WDOG
    jsr       BIOSF_SYSTEM_IO                   | update inputs etc
    move.b    BIOS_P1CURRENT,d0                 | read IN1
    and.b     #0x30,d0                          | any buttons pressed?
    beq.b     3b                                | no, loop
4:  jsr       BIOSF_FIX_CLEAR
    clr.b     REG_PALBANK0                      | main palette bank
.endif | OPT_SKIP_SPLASH
    
5:  KICK_WDOG
    rts

splash:
    *         "  [--------------------------]  "
    .ascii    "                                "
    .ascii    "             PENGO      Beta1   "
    .ascii    "                                "
    .ascii    "            NGH 422             "
    .ascii    "                                "
    .ascii    "  This is a 68K transcode of    "
    .ascii    "  the arcade game Pengo         "
    .ascii    "  released by SEGA in 1982.     "
    .ascii    "                                "
    .ascii    "  The core is a line-by-line    "
    .ascii    "  translation of the Z80        "
    .ascii    "  assembler code. Every         "
    .ascii    "  nuance and every bug is       "
    .ascii    "  faithfully replicated in      "
    .ascii    "  the transcode. The graphics   "
    .ascii    "  and palette have been         "
    .ascii    "  ripped as-is from the         "
    .ascii    "  arcade ROMs for use in this   "
    .ascii    "  version.                      "
    .ascii    "                                "
    .ascii    "  The Neo Geo version supports  "
    .ascii    "  high score load and save on   "
    .ascii    "  both BRAM and memory card.    "
    .ascii    "                                "
    .ascii    "  Arcade dipswitches are        "
    .ascii    "  supported via the soft DIPs.  "
    .ascii    "                                "
    .ascii    "                                "
    .ascii    "                                "
    .ascii    "                                "
    .ascii    "                                "
    .ascii    "        Z80 RE by jotd          "
    .ascii    "     68K transcode by jotd      "
    .ascii    "     Sound samples by jotd      "
    .ascii    "  NGFX Soundbuilder by Blastar  "
    .ascii    "                                "
    .ascii    "     Copyright 2023 tcdev       "
    .ascii    "    retroports.blogspot.com     "
    .byte     0
    .align 2

splash_attr:
    .word     0x2000, 0x2000, 0x2000, 0x0000
    .word     0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000
    .word     0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000
    .word     0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000, 0x1000
    .word     0x1000, 0x1000
    .word     0x1000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1000
    .word     0x2000, 0x2000
            
* 60Hz VBLANK interrupt
osd_enable_vblank_interrupt:
    move      #0x2000,sr                        | enable interrupts
    rts

osd_ack_vblank_interrupt:
    move.w    #4,REG_IRQACK                     
    rts
    
osd_disable_vblank_interrupt:
    move      #0x2400,sr                        | enable interrupts
    rts

osd_r_videoram:
    movem.l   d6/a0,-(a7)
    lea       bg_videoram,a0
    and.w     #0x03ff,d6                        | restrict offset
    move.b    (a0,d6.w),d0
    movem.l   (a7)+,d6/a0
    rts
        
* d6=screen address (preserved), d0=tile (preserved)
* should preserve all registers

osd_w_videoram:
    .ifeq OPT_DISABLE_BG_LAYER
    movem.l   d0-d6/a0/a1,-(a7)
    lea       bg_videoram,a0
    and.w     #0x3ff,d6                         | calc offset
    move.b    d0,(a0,d6.w)                      | save code to bg_videoram
    lea       fg_offset_lookup_tbl,a0
    add.w     d6,d6
    move.w    (a0,d6.w),a1                      | map video offset
    * calculate Neo Geo tile
    andi.w    #0x00ff,d0
    ori.w     #BG_TILE_BASE,d0
    or.w      (m_charbank),d0
    move      sr,d4                             | save interrupt mask
    move      #0x2400,sr                        | disable vblank
    lea       VRAM_RW.l,a0
*    move.w    #1,(2,a0)                         | VRAM_MOD=1
    move.w    a1,(-2,a0)                        | VRAM_ADDR=SCB1
    move.w    d0,(a0)
    move      d4,sr                             | restore interrupt mask
9:  movem.l   (a7)+,d0-d6/a0/a1
    .endif | OPT_DISABLE_BG_LAYER
    rts

* 6000: in D0
*    bits 0-1: coin1 & coin2
*    bit  2: joy move left
*    bit  3: joy move right
* 6800: in D1
*    bits 7-6: if both set, means FREE PLAY
* 1 COIN = 1 PLAY               OFF           OFF
* 2 COINS = 1 PLAY              ON            OFF
* 1 COIN = 2 PLAYS              OFF           ON
* FREE PLAY                     ON            ON 

* 7000: in D2
*    bits 0-1: Values for BONUS GALIXIP. 7 = 7000, 10 = 10000, 12 =12000, 20 = 20000
*    bits 2-3: ????

osd_r_colorram:
    movem.l   d6/a0,-(a7)
    and.w     #0x03ff,d6                        | restrict offset
    lea       bg_videoram,a0
    move.b    (a0,d6.w),d0
    movem.l   (a7)+,d6/a0
    rts

* d6=offset, d0=attrib
osd_w_colorram:
    movem.l   d4/d6/a0/a1,-(a7)
    and.w     #0x03ff,d6                        | restrict offset
    lea       bg_videoram,a0
    move.b    d0,(a0,d6.w)
    lea       fg_offset_lookup_tbl,a0
    add.w     d6,d6
    move.w    (a0,d6.w),a1                      | map video offset
    lea       (1,a1),a1                         | palette word
    move      sr,d4                             | save interrupt mask
    move      #0x2400,sr                        | disable vblank
    lea       VRAM_RW.l,a0
*    move.w    #1,(2,a0)                         | VRAM_MOD=1
    move.w    a1,(-2,a0)                        | VRAM_ADDR=SCB1
    and.w     #0x1f,d0                          | bits 4-0
    or.w      (m_colortablebank),d0
    or.w      (m_palettebank),d0
    lsl.w     #8,d0                             | shift into palette bits
    move.w    d0,(a0)
    move      d4,sr                             | restore interrupt mask
    movem.l   (a7)+,d4/d6/a0/a1
    rts
            
osd_read_dipswitches:
    * coin
    * - need to "pulse-extend" coin input
    *   because Galaxian core debounces it
    tst.b     (_coin_pulse_cnt)
    beq       0f
    subq.b    #1,(_coin_pulse_cnt)
    move.b    (_coin_value),d0
    bra       1f
0:  lea       BIOS_CREDIT_DEC1.l,a0
    move.l    a0,-(a7)
    move.w    #0x0100,(a0)                      | PLAYER1 1C1C
    jsr       BIOSF_CREDIT_CHECK
    move.l    (a7)+,a0
  	move.b	  #0x03,d0                          | bits1,0 active low
    move.w    (a0),d3                           | read result
    cmpi.w    #0x0100,d3                        | enough credits?
    bne.b     1f                                | no, skip
    move.l    d0,-(a7)
    jsr       BIOSF_CREDIT_DOWN                 | deduct credit
    move.l    (a7)+,d0
    bclr      #0,d0                             | coin1 (active low)
    move.b    d0,(_coin_value)
    move.b    #8,(_coin_pulse_cnt)
    * start
1:  move.b    BIOS_STATCURNT,d3                 | bit0=P1, bit2=P2
    andi.b    #1,d3                             | P1 only atm
    lea       BIOS_GAME_DIP,a0
    move.b    (7,a0),d1                         | coinage
    lsl.b     #6,d1                             | ->[7:6]
    or.b      d3,d1                             | start 1,2
    * 7000 (dips)
    move.b    (8,a0),d2                         | bonus {1:0]
    move.b    (9,a0),d3                         | lives {0]
    lsl.b     #2,d3                             | ->[2]
    or.b      d3,d2                             | lives,bonus
    * inputs
    * - neogeo   5=B2, 4=B1, 3=right, 2=left, 1=down,  0=up
    move.b    BIOS_P1CURRENT,d3                 | read IN1
    and.b     #0x1C,d3                          | B1, right, left
    or.b      d3,d0                             | add inputs
    rts

* - neogeo   5=B2, 4=B1, 3=right, 2=left, 1=down,  0=up

* coin in d0 and set Z flag on exit too
osd_read_coin:
    tst.b     (BIOS_MVS_FLAG)
    beq       home_use
*   The NEO GEO BIOS handles credits and coins for you
*   so we always use 1C1C here and let Xevious handle the
*   actual credits itself
    * check HW dips first
    moveq     #0,d0                             | default no coin
    *btst.b    #6,(REG_DIPSW)                    | freeplay (active low)?
    *bne.b     0f                                | no, go
    * how do we handle freeplay setting?
    *bra       9f
0:  lea       BIOS_CREDIT_DEC1.l,a0
    move.l    a0,-(a7)
    move.w    #0x0100,(a0)                      | PLAYER1 1C1C
    jsr       BIOSF_CREDIT_CHECK
    move.l    (a7)+,a0
    move.w    (a0),d1                           | read result
    cmpi.w    #0x0100,d1                        | enough credits?
    beq.b     1f                                | yes, skip
    bra       9f
1:  jsr       BIOSF_CREDIT_DOWN                 | deduct credit
    bra       coin_inserted
home_use:   
    * fix me
    move.b    (BIOS_STATCHANGE),d6
    btst.b    #1,d6                             | <SELECT> changed?
    beq.b     9f                                | no, skip
    move.b    BIOS_STATCURNT,d1                 | read start buttons
    btst.b    #1,d1                             | <SELECT> pressed?
    beq.b     9f
coin_inserted:    
    moveq     #1,d0
9:  tst.b     d0
    rts
    
.equ  ADPCM_MUTE,           0x16
.equ  ADPCM_SET_MAX_VOL,    0x17
.equ  ADPCM_STOP,           0x18
.equ  ADPCMA_LOOP_STOP,     0x19
.equ  ADPCMB_LOOP_STOP,     0x1a

osd_sound_enable:
    rts
    
osd_sound_disable:
    rts
    
* d0 = sound ordinal
osd_sound_start:
    add.w     #0x20,d0                          | calc sound command
    move.b    d0,(REG_SOUND)
    rts

* d0 = sound ordinal
osd_sound_stop:
    move.b    #ADPCM_STOP,(REG_SOUND)
9:  rts

osd_sound_mute:
    move.b    #ADPCM_MUTE,(REG_SOUND)
    rts
    
osd_sound_unmute:
    move.b    #ADPCM_SET_MAX_VOL,(REG_SOUND)
    rts

* < A0: pointer on 8FF2 zone:
* the first byte contains the sprite image number (bits 2-7), Y flip (bit 0),
*                        X flip (bit 1); the second byte the color
* < A1: pointer on 9022 zone (X,Y coords)

osd_update_sprites:
    movem.l   d0-d7/a0-a2,-(a7)
    lea       VRAM_RW.l,a2
    move.w    #1,(2,a2)                         | VRAM_MOD=1
    ** SPRITES
    ** FIXME - lower sprites have priority!!! ??? check this
    ** SCB1
    move.w    #SCB1+PSSS*64,d2
    moveq     #PSNS-1,d7
1:  move.w    d2,(-2,a2)                        | VRAM_ADDR=SCB1
    moveq     #0,d0
    move.b    (0,a0),d0                         | code
    lsr.b     #2,d0                             | 7:2->5:0
    ori.w     #PS_TILE_BASE,d0
    or.b      (m_spritebank),d0                 | 6:0
    move.w    d0,(a2)                           | store
    move.b    (1,a0),d0                         | colour
    lsl.w     #8,d0                             | shift to high byte
    move.b    (0,a0),d1                         | flip
    and.w     #3,d1                             | x,y flip only
    or.b      d1,d0                             | combine
    move.w    d0,(a2)                           | store
    lea       (2,a0),a0                         | next sprite
    add.w     #64,d2                            | next VRAM_ADDR
    dbf       d7,1b
    ** SCB3
    move.w    #SCB3+PSSS,(-2,a2)                | VRAM_ADDR=SCB3
    moveq     #PSNS-1,d7
2:  moveq     #0,d1
    move.b    (0,a1),d1                         | pengo sprite Y
    move.w    #SPRITEY_0+16,d0
    sub.w     d1,d0                             | Neo Geo adjust
    lsl.w     #7,d0                             | shift up
    cmp.b     #0,d1                             | Y=0 (not visible)?
    beq       3f                                | yes, skip
    ori.w     #1,d0                             | size=1
3:  move.w    d0,(a2)                           | store
    lea       (2,a1),a1                         | next sprite
    dbf       d7,2b
    ** SCB4
    suba.l    #0x10,a1
    move.w    #SCB4+PSSS,(-2,a2)                | VRAM_ADDR=SCB4
    moveq     #PSNS-1,d7
4:  moveq     #0,d1
    move.b    (1,a0),d1                         | pengo sprite X
    move.w    #0x0109,d0
    sub.w     d1,d0                             | Neo Geo adjust
    lsl.w     #7,d0                             | shift up
    move.w    d0,(a2)                           | store
    lea       (2,a1),a1                         | next sprite
    dbf       d7,4b

9:  movem.l   (a7)+,d0-d7/a0-a2
    rts

* d0 bit2 = m_palettebank
*    bit6 = m_colourtablebank
*    bit7 = m_spritebank & m_charbank
osd_set_bank_selectors:
    move.l    d1,-(a7)
    move.b    d0,d1
    lsl.b     #4,d1                             | 2->6
    and.w     #0x0040,d1
    move.w    d1,(m_palettebank)
    move.b    d0,d1
    lsr.b     #1,d1                             | 6->5
    and.w     #0x0020,d1
    move.w    d1,(m_colortablebank)
    lsl.b     #1,d0                             | 7->8
    and.w     #0x0100,d0
    move.w    d0,(m_spritebank)
    move.w    d0,(m_charbank)
    move.l    (a7)+,d1
    rts
    
***
*** high score format
*** - high score table (a0) $50 bytes
***   - 5 entries
***     - 3 bytes BCD score (MSB-LSB)
***     - 10 bytes name (xevious encoded)
***     - 3 bytes filler ($00)
*** - high score (a1) $3 bytes
***   - 3 bytes BCD score (MSB-LSB)
***   - (no need to save this explicitly)
***

*** BRAM (MVS only)
*** Memory card (MVS,AES,NGCD)

* a2=memcard_buf
patch_high_score_table:
    lea       (20+28,a2),a2                     | skip header
    * extract high score from entry 1
    move.b    (a2)+,(a0)+
    move.b    (a2)+,(a0)+
    move.b    (a2)+,(a0)+
    rts

* a0 = high score buffer (3 bytes)
osd_read_high_scores:
    lea       memcard_buf,a2
    * try to read from BRAM first
    * - any memory card saves will overwrite
.ifndef __cd__
    tst.b     (BIOS_MVS_FLAG)                   | MVS?
    beq       check_memcard_data                | no, skip
check_BRAM_data:
    move.l    (a2),d0                           | from buffer
    cmp.l     (memcard_hdr),d0                  | valid save data?
    bne.b     check_memcard_data                | no, skip
    movem.l   a0-a1,-(a7)
    bsr.b     patch_high_score_table
    movem.l   (a7)+,a0-a1
.endif | __cd__

check_memcard_data:    
    movem.l   d0-d7/a0-a6,-(a7)
    * try reading card data first
    move.b    #0x01,(BIOS_CRDF)
    move.w    #__NGH__,(BIOS_CRDNGH)
    jsr       BIOSF_CARD
    move.b    (BIOS_CRDRESULT),d0
    bne.b     2f
    * found some data for Galaxian
    move.b    #0x02,(BIOS_CRDF)
    move.w    #__NGH__,(BIOS_CRDNGH)
    move.b    #0,d0
    move.b    d0,(BIOS_CRDFILE)
    lea       memcard_buf,a2
    move.l    a2,(BIOS_CRDPTR)
    move.w    #64,(BIOS_CRDSIZE)                | 1 block only
    jsr       BIOSF_CARD
    move.b    (BIOS_CRDRESULT),d0
    bne       9f                                | error reading, exit
    movem.l   (a7)+,d0-d7/a0-a6
    lea       memcard_buf,a2
    bra       patch_high_score_table

    * handle card search data errors
2:  cmp.b     #0x80,d0                          | not inserted?
    beq.b     9f                                | not, return
    cmp.b     #0x81,d0                          | not formatted?
    bne.b     3f                                | not, go
    * format card
    move.b    #0x00,(BIOS_CRDF)
    jsr       BIOSF_CARD
    move.b    (BIOS_CRDRESULT),d0
    * not much we can do about failure
    bra.b     9f
3:  cmp.b     #0x82,d0                          | no data?
    beq.b     9f                                | no data, return
    nop
9:  movem.l   (a7)+,d0-d7/a0-a6
    rts

* a0 = high scotr buffer (3 bytes)    
osd_write_high_scores:
    movem.l   d0-d7/a0-a6,-(a7)
    * init memcard buffer
    lea       memcard_hdr,a1
    lea       memcard_buf,a2
    move.w    #20+28-1,d7
2:  move.b    (a1)+,(a2)+
    dbf       d7,2b
    * copy high scores to memcard buffer
    move.w    #3-1,d7
3:  move.b    (a0)+,(a2)+
    dbf       d7,3b
    
    * write to BOTH BRAM and memcard (if valid)
    
.ifndef __cd__
    tst.b     (BIOS_MVS_FLAG)                   | MVS?
    beq       write_memcard_data                | no, skip
    *** write to BRAM first
write_BRAM_data:
    lea       0x10F300,a5
    move.b    #1,(0xBBF,a5)                     | mark BRAM as being used
    jsr       0xC12322                          | init_workbackup_ram
    clr.b     (0xBBF,a5)                        | unmark BRAM as being used
.endif | __cd__

    *** write to memcard
write_memcard_data:
    move.b    #0x03,(BIOS_CRDF)
    move.w    #__NGH__,(BIOS_CRDNGH)
    move.b    #0,(BIOS_CRDFILE)
    lea       memcard_buf,a2
    move.l    a2,(BIOS_CRDPTR)
    move.w    #64,(BIOS_CRDSIZE)                | 1 block
    jsr       BIOSF_CARD
    move.b    (BIOS_CRDRESULT),d0
    bne       9f                                | error writing, exit
9:  movem.l   (a7)+,d0-d7/a0-a6
    rts

    .align 4
memcard_hdr:
    .byte     'P','E','N','G','O',' ',' ',' '
    .byte     ' ',' ',' ',' ',' ',' ',' ',' '
    .byte     ' ',' ',' ',' '
    .byte     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    .byte     0,0,0,0,0,0,0,0,0,0,0,0
        
* d0=backdropcolour
osd_debug_hook:
    move.w    d0,(BACKDROPCOLOR)
    rts

osd_break:
    rts
            
_end_of_ng_code:
    
    .text
    .align 2  
.include "neogeo/palette.68k"

    .bss

    .align 4
fg_offset_lookup_tbl:         ds.w  0x0400

snd_playing:                  ds.b    0x20

    .align 4
memcard_buf:
memcard_buf_0:                | pengo
    mc_title_0:               ds.b  20
                              ds.b  28
    mc_scores_0:              ds.b  3
    mc_filler_0:              ds.b  (64-(20+28+3))

_cabinet:                     ds.b  1

_coin_value:                  ds.b  1
_coin_pulse_cnt:              ds.b  1
_tile_colour:                 ds.b  32
_tile_scroll:                 ds.b  32
  .align 2
m_palettebank:                ds.w  1
m_colortablebank:             ds.w  1
m_spritebank:                 ds.w  1
m_charbank:                   ds.w  1

_end_of_ng_data:
    