
*
* 68k transcode by JOTD in 2023 using (https://github.com/jotd666/amiga68ktools)
  
* register conventions (imposed by z80268k mostly) are as follows:
*
* A: D0
* B: D1
* C: D2
* BC: manual
* D: D3
* E: D4
* DE: A1
* H: D5
* L: D6
* HL: A0 or D6 (video addresses)
* carry: manual, using D7 (push/pop af has no portable equivalent as SR is privileged on 68020+)
*
* depending on the context H/L/HL and D/E/DE require rework as the game
* constructs pointers from 0x100-page aligned pointers to avoid to handle
* lsb wrap and msb increase. Of course the 68000 can do that so easily. But
* it cannot split address registers :) 
*
* screen addresses (0x8000-0x8400) are usually pointed by HL but in the API
* I chose to store the value in D6 as it's not really an address now but rather
* an offset to video memory once you subtract 0x8000

*    0000-7fff ROM
*    8000-83ff Video RAM
*    8400-87ff Color RAM
*    8800-8fff RAM
*
*    memory mapped ports:
*
*    read:
*    9000      DSW1
*    9040      DSW0
*    9080      IN1
*    90c0      IN0
*
*    write:
*    8ff2-8ffd 6 pairs of two bytes:
*              the first byte contains the sprite image number (bits 2-7), Y flip (bit 0),
*              X flip (bit 1); the second byte the color
*    9005      sound voice 1 waveform (nibble)
*    9011-9013 sound voice 1 frequency (nibble)
*    9015      sound voice 1 volume (nibble)
*    900a      sound voice 2 waveform (nibble)
*    9016-9018 sound voice 2 frequency (nibble)
*    901a      sound voice 2 volume (nibble)
*    900f      sound voice 3 waveform (nibble)
*    901b-901d sound voice 3 frequency (nibble)
*    901f      sound voice 3 volume (nibble)
*    9022-902d Sprite coordinates, x/y pairs for 6 sprites
*    9040      interrupt enable
*    9041      sound enable
*    9042      palette bank selector
*    9043      flip screen
*    9044-9045 coin counters
*    9046      color lookup table bank selector
*    9047      character/sprite bank selector
*    9070      watchdog reset
*
*static INPUT_PORTS_START( pengo )
*	PORT_START("IN0")
*	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_4WAY
*	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_4WAY
*	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_4WAY
*	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_4WAY
*	/* the coin input must stay low for no less than 2 frames and no more
*	   than 9 frames to pass the self test check.
*	   Moreover, this way we avoid the game freezing until the user releases
*	   the "coin" key. */
*	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(2)
*	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN2 ) PORT_IMPULSE(2)
*	/* Coin Aux doesn't need IMPULSE to pass the test, but it still needs it
*	   to avoid the freeze. */
*	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN3 ) PORT_IMPULSE(2)
*	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON1 )
*
*	PORT_START("IN1")
*	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_4WAY PORT_COCKTAIL
*	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_4WAY PORT_COCKTAIL
*	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_4WAY PORT_COCKTAIL
*	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_4WAY PORT_COCKTAIL
*	PORT_SERVICE_NO_TOGGLE(0x10, IP_ACTIVE_LOW)
*	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START1 )
*	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_START2 )
*	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL
*
*	PORT_START("DSW0")
*	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Bonus_Life ) )       PORT_DIPLOCATION("SW1:1")
*	PORT_DIPSETTING(    0x00, "30000" )
*	PORT_DIPSETTING(    0x01, "50000" )
*	PORT_DIPNAME( 0x02, 0x00, DEF_STR( Demo_Sounds ) )      PORT_DIPLOCATION("SW1:2")
*	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
*	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
*	PORT_DIPNAME( 0x04, 0x00, DEF_STR( Cabinet ) )          PORT_DIPLOCATION("SW1:3")
*	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
*	PORT_DIPSETTING(    0x04, DEF_STR( Cocktail ) )
*	PORT_DIPNAME( 0x18, 0x10, DEF_STR( Lives ) )            PORT_DIPLOCATION("SW1:4,5")
*	PORT_DIPSETTING(    0x18, "2" )
*	PORT_DIPSETTING(    0x10, "3" )
*	PORT_DIPSETTING(    0x08, "4" )
*	PORT_DIPSETTING(    0x00, "5" )
*	PORT_DIPNAME( 0x20, 0x20, "Rack Test (Cheat)" ) PORT_CODE(KEYCODE_F1)   PORT_DIPLOCATION("SW1:6")
*	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
*	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
*	PORT_DIPNAME( 0xc0, 0x80, DEF_STR( Difficulty ) )       PORT_DIPLOCATION("SW1:7,8")
*	PORT_DIPSETTING(    0xc0, DEF_STR( Easy ) )
*	PORT_DIPSETTING(    0x80, DEF_STR( Medium ) )
*	PORT_DIPSETTING(    0x40, DEF_STR( Hard ) )
*	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
*
*	PORT_START("DSW1")
*	PORT_DIPNAME( 0x0f, 0x0c, DEF_STR( Coin_A ) )           PORT_DIPLOCATION("SW2:1,2,3,4")
*	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) )
*	PORT_DIPSETTING(    0x08, DEF_STR( 3C_1C ) )
*	PORT_DIPSETTING(    0x04, DEF_STR( 2C_1C ) )
*	PORT_DIPSETTING(    0x09, "2 Coins/1 Credit 5/3" )
*	PORT_DIPSETTING(    0x05, "2 Coins/1 Credit 4/3" )
*	PORT_DIPSETTING(    0x0c, DEF_STR( 1C_1C ) )
*	PORT_DIPSETTING(    0x0d, "1 Coin/1 Credit 5/6" )
*	PORT_DIPSETTING(    0x03, "1 Coin/1 Credit 4/5" )
*	PORT_DIPSETTING(    0x0b, "1 Coin/1 Credit 2/3" )
*	PORT_DIPSETTING(    0x02, DEF_STR( 1C_2C ) )
*	PORT_DIPSETTING(    0x07, "1 Coin/2 Credits 5/11" )
*	PORT_DIPSETTING(    0x0f, "1 Coin/2 Credits 4/9" )
*	PORT_DIPSETTING(    0x0a, DEF_STR( 1C_3C ) )
*	PORT_DIPSETTING(    0x06, DEF_STR( 1C_4C ) )
*	PORT_DIPSETTING(    0x0e, DEF_STR( 1C_5C ) )
*	PORT_DIPSETTING(    0x01, DEF_STR( 1C_6C ) )
*	PORT_DIPNAME( 0xf0, 0xc0, DEF_STR( Coin_B ) )           PORT_DIPLOCATION("SW2:5,6,7,8")
*	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) )
*	PORT_DIPSETTING(    0x80, DEF_STR( 3C_1C ) )
*	PORT_DIPSETTING(    0x40, DEF_STR( 2C_1C ) )
*	PORT_DIPSETTING(    0x90, "2 Coins/1 Credit 5/3" )
*	PORT_DIPSETTING(    0x50, "2 Coins/1 Credit 4/3" )
*	PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) )
*	PORT_DIPSETTING(    0xd0, "1 Coin/1 Credit 5/6" )
*	PORT_DIPSETTING(    0x30, "1 Coin/1 Credit 4/5" )
*	PORT_DIPSETTING(    0xb0, "1 Coin/1 Credit 2/3" )
*	PORT_DIPSETTING(    0x20, DEF_STR( 1C_2C ) )
*	PORT_DIPSETTING(    0x70, "1 Coin/2 Credits 5/11" )
*	PORT_DIPSETTING(    0xf0, "1 Coin/2 Credits 4/9" )
*	PORT_DIPSETTING(    0xa0, DEF_STR( 1C_3C ) )
*	PORT_DIPSETTING(    0x60, DEF_STR( 1C_4C ) )
*	PORT_DIPSETTING(    0xe0, DEF_STR( 1C_5C ) )
*	PORT_DIPSETTING(    0x10, DEF_STR( 1C_6C ) )
*INPUT_PORTS_END

*	;; pengo
*	;; 33E6:	main A.I. routine to decrypt
*
*	pengo_moving_direction_8CF4:
*   0x0: not moving
*   0x8: up
*   0x9: down
*   0xA: left
*   0xB: right
*   plus bit 2 set when breaking ice block/hitting wall (down+break = 0xD)

*	;; 8D00 -> 8D80 characters. snobees first then pengo & moving block
*
*	+ 00:	x min 19 max D8 1 block = 0x8  (coords = 0: invisible)
*	+ 01:	y min 11 max F0 1 block = 0x10
*	+ 03:	snobee color
*	+ 04:	facing direction (0 up, 1 down, 2 left, 3 right)
*   + 05:   snobee/character index
*	+ 06:	instant move period (can be different from the one in 1C)
*	+ 07:	current period counter (increased automatically)
*	+ 09:
*	+ 0A:	stunned counter (used for stun/blinking stun)
*	+ 1B:	 ?????
*	+ 1C:	move period for this level
*		pengo move period is 0A
*		easy level = 0C at act 1
*		medium level = 0B at act 1
*		hard = 0A (same speed as pengo at 1st level)
*		hardest = 09, 08 from act 5 (always faster than pengo)
*	+ 1D:	backup of 1E when block avoidance mode
*	+ 1E:	A.I. mode when 1F = 02
*		00 block avoidance mode (only active when a block is moving)
*	        01 roaming mode: wanders randomly, breaking no blocks, no hunt. But tries to avoid moving blocks
*	        02 block breaking mode:	wanders randomly, breaking all the blocks. Tries to avoid moving blocks that pengo throws
*		03 hunt mode 1:	X based (see description for details)
*		04 hunt mode 2:	exactly like 03 but y based
*		05 hunt mode 3:	combination of hunt modes 1 and 2: this is the most aggressive one, x & y based
*		06 roaming mode: same as 01
*		07 roaming mode: same as 01
*		08 hunt mode: same as 05
*		09 chicken mode: go up to reach upper border
*		0A chicken mode: go down to reach lower border
*		0B chicken mode: go left to reach left border
*		0C chicken mode: right to right border
*		0D chicken mode: on border, going up to corner
*		0E chicken mode: on border, going down to corner
*		0F chicken mode: on border, going left to corner
*		10 chicken mode: on border, going right to corner
*
*	+ 1F:	behaviour (state machine, next state is state+1)
*
*		00: dead, and no more eggs
*		01: alive and contemplating a move (static)
*		02: alive and moving
*		03: transition to stunned: keeps moving until aligned on grid
*		04: stunned (aligned on grid)
*		05: blinking stunned
*		06: stunned picked by pengo:	100 points
*		09  pushed by block (short transitions to 0A)
*		0A  pushed by block
*		0B  crushed by block
*		0C  crushed by block:	 gives 400/1600/... score
*		0D  about to hatch (short transitions to 0E)
*		0E  about to hatch (short transitions to 0F)
*		0F  hatching

* named offsets for character structure
x_pos = 0x0
y_pos = 0x01
animation_frame = 0x02
char_color = 0x03
facing_direction = 0x04
char_id = 0x05
instant_move_period = 0x06
current_period_counter = 0x07
unknown_09 = 0x09
* stunned counter for snobees, push block counter for pengo
stunned_push_block_counter = 0x0A
* maybe used for other misc snobees animations as well
intermission_dance_counter = 0x0B
alive_walk_counter = 0x0C
unknown_1A = 0x1A
unknown_1B = 0x1B
move_period = 0x1C
backup_ai_mode = 0x1D
ai_mode = 0x1E
char_state = 0x1F

 * snobee move routine is "02_snobee_moving_33A5"
 * the A.I. is done in handle_snobee_direction_change_33D8

 * A.I. is handled as follows:
 *
 * - when eggs hatch at startup, behaviour is random from 8 possibles (code at 0x3CAE)
 * - when stunned on a border/diamond align, if not killed, snobee
 *   switches to 02:	 block breaking
 * - when a snobee is killed and an egg hatches, game scans A.I. of
 *   all alive snobees and sets one in 02: block breaking mode
 *   if not already one in that state

 * pengo struct 8D80 (shares a lot of members with snoobees)

*	+ 00:	x (coords = 0: invisible)
*	+ 01:	y
*	+ 02:	animation frame / sprite tile code
*	+ 03:	pengo color (can be changed, very funny effect!!)
*	+ 04:	facing direction 0:up,1:down,2:	left,3:	right
*	+ 05:	fixed to 5:	character index (pengo, change to sno bee with 0!)
*	+ 06:	speed (fixed to 0A, make it super fast by decreasing value!!)
*	+ 08:	moving FF=true 0=false
*	+ 0F:	fire pressed FF=true 0=false
*	+ 12:	saved number of seconds
*	+ 13:	saved number of minutes
*	+ 1E:	000x: alive, 0xFF: dead
*	+ 1F:	state.
*        1 stand-by (get ready)
*        2 walking
*        3 invalid state that reboots the game !!
*        4 breaking block
*        5 shaking wall
*        6 dying
*
*	;; moving block struct 8DA0 (Pengo can only push 1 block at a time)
*	+ 00:	x (coords = 0: invisible)
*	+ 01:	y
*	+ 04:	direction (0,1,2,3)
*	+ 0F:	number of snobee hit by this block
*	+ 1F:	00: not moving, 02: moving
* exports

    * ROM

    .global pengo_irq
    .global pengo_reset

	
	.include "pengo.inc"
	.ifdef	__amiga__
	.include "pengo_ram.68k"
	.align	2
	.endif
	
* < A0: source (HL)
* < D1: length to search
* > D0.B value searched for (A)
* > Z flag if found
cpir:
    subq.w    #1,d1
0:
    cmp.b    (a0)+,d0
    beq.b    1f
    dbf        d1,0b
    clr.w    d1
    * not found: unset Z
    cmp.b   #1,d1
1:
    rts
	
pengo_reset:
	* default: 1 update/irq call
	* we need 60 updates / second so on amiga PAL
	* we need to set this variable to 2 once out of 5 calls
	move.b	#1,vb_ticks_count

	
	jra		INITIALISE_SYSTEM

	
	nop
INITIALISE_SYSTEM:
	                      	| [ld   hl,0x0000]
	clr.w	unknown_8830     | [ld   (unknown_8830),hl]
	jra	l_03d4             
	

pengo_irq:
	move.w	cursor_x_8800,-(sp)
	move.w	cursor_color_8802,-(sp)
	move.b	delay_timer_8820,d0             	| [ld   a,(delay_timer_8820)]
	jeq	l_0057                             	| if delay_timer_8820 == 0 goto 0x57 [jr   z,0x0057]
	subq.b	#1,d0                           	| else decrease it [dec  a]
	move.b	d0,delay_timer_8820             	| and write it back [ld   (delay_timer_8820),a]
l_0057:
	move.b	delay_timer_2_8821,d0           	| same for other timer [ld   a,(delay_timer_2_8821)]
	jeq	l_0061                             	| skip if 0 [jr   z,0x0061]
	subq.b	#1,d0                           	| decrease it [dec  a]
	move.b	d0,delay_timer_2_8821           	| and write it back [ld   (delay_timer_2_8821),a]
l_0061:
	move.b	unknown_87FF,d0                       	| [ld   a,(0x87FF)]
	jne	l_013f                             	| [jp   nz,0x013F]
	addq.w	#1,timer_16bit_8822         	| [ld   hl,(timer_16bit_8822)]
	jbsr	l_32bc                            	| [call 0x32BC]
	* temp coin shit disabled
	*jbsr	l_02a2   coin                         	| [call 0x02A2]
	*jbsr	l_02cd 	 coin                           	| [call 0x02CD]
	*jbsr	l_027f   coin                         	| [call 0x027F]
	*jbsr	l_03b2                            	| [call 0x03B2]
	*jbsr	l_03aa                            	| [call 0x03AA]
	
	lea	time_counter_8C5B,a0           	| [ld   hl,time_counter_8C5B]
	addq.b	#1,(a0)                         	| [inc  (hl)]
	move.b	#0x3D,d0                        	|  61 "microsecs" [ld   a,0x3D]
	cmp.b	(a0),d0                          	| [cp   (hl)]
	jcc	l_009e                             	| [jr   nc,0x009E]
	clr.b	(a0)                             	| [ld   (hl),0x00]
	addq.w	#1,a0                           	| [inc  hl]
	addq.b	#1,(a0)                         	|  1 more second [inc  (hl)]
	move.b	#0x3B,d0                        	|  59 seconds [ld   a,0x3B]
	cmp.b	(a0),d0                          	| [cp   (hl)]
	jcc	l_009e                             	| [jr   nc,0x009E]
	clr.b	(a0)                             	| [ld   (hl),0x00]
	addq.w	#1,a0                           	| [inc  hl]
	addq.b	#1,(a0)                         	|  1 more minute [inc  (hl)]
	cmp.b	(a0),d0                          	| [cp   (hl)]
	jcc	l_009e                             	| [jr   nc,0x009E]
* reset minute counter
	clr.b	(a0)                             	| [ld   (hl),0x00]
	addq.w	#1,a0                           	| [inc  hl]
* add hour, never called obviously as round "times out" before 2 minutes
* by monsters fleeing the scene
	addq.b	#1,(a0)                         	| [inc  (hl)]
l_009e:
	* skipped all sound update
l_013f:
	* restore cursor positions if used during interrupt
	move.w	(sp)+,cursor_color_8802            	| [ld   (cursor_color_8802),a]
	move.w	(sp)+,cursor_x_8800                	| [ld   (cursor_x_8800),hl]

	jbsr	l_015b                            	| [call 0x015B]
	**jbsr	l_0179                            	| [call 0x0179]
	rts
	

l_015b:
	move.b	currently_playing_8819,d0       	| [ld   a,(currently_playing_8819)]
	tst.b	d0                               	| [and  a]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	move.b	number_of_credits_8808,d0       	| [ld   a,(number_of_credits_8808)]
	tst.b	d0                               	| [and  a]
	bne.b	0f
	rts                                    	| [ret  z]
0:
 * start game (credits inserted)
	move.b	#0x01,d0                        	| [ld   a,$01]
	move.b	d0,currently_playing_8819       	| [ld   (currently_playing_8819),a]
*ld   sp,stack_pointer_8FF0
	lea	coin_has_been_inserted_0490(pc),a0                      	| [ld   hl,$0490]
	move.l	a0,-(sp)                        	| [push hl]
	**move.b	#0x01,d0                        	| [ld   a,$01]
	**move.b	d0,dip_switches_9040            	| [ld   (dip_switches_9040),a]
	rts
	

	
l_03d4:
* zero a lot of hardware stuff
	jbsr	osd_sound_disable
	clr.b	d0                               	| [xor  a]
*	move.b	d0,dip_switches_9040            	| [ld   (dip_switches_9040),a]
*	move.b	d0,sound_enable_9041            	| [ld   (sound_enable_9041),a]
*	move.b	d0,flip_screen_9043             	| [ld   (flip_screen_9043),a]
*	move.b	d0,coin_counter_9044            	| [ld   (coin_counter_9044),a]
*	move.b	d0,coin_counter_9045            	| [ld   (coin_counter_9045),a]
*	move.b	d0,character_sprite_bank_selector_9047	| [ld   (character_sprite_bank_selector_9047),a]
*	move.b	d0,palette_bank_selector_9042   	| [ld   (palette_bank_selector_9042),a]
*	move.b	d0,color_lookup_table_bank_selector_9046	| [ld   (color_lookup_table_bank_selector_9046),a]
	clr.b	d0                               	| [xor  a]
* zero a lot of global counters
	move.b	d0,number_of_credits_8808       	| [ld   (number_of_credits_8808),a]
*	move.b	a0,unknown_8809                 	| [ld   (unknown_8809),hl]
*	move.b	d0,unknown_880B                 	| [ld   (unknown_880B),a]
*	move.b	a0,unknown_881C                 	| [ld   (unknown_881C),hl]
*	move.b	a0,unknown_881E                 	| [ld   (unknown_881E),hl]

	jbsr	enable_sound_18EC                 	| [call enable_sound_18EC]
	
	jbsr	osd_enable_vblank_interrupt
	
	clr.b	d0                               	| [xor  a]
	move.b	d0,unknown_8828                 	| [ld   (unknown_8828),a]
	move.b	d0,unknown_8829                 	| [ld   (unknown_8829),a]
	clr.w	player_1_score_880E          	| [ld   (player_1_score_880E),hl]
	clr.w	player_2_score_8810          	| [ld   (player_2_score_8810),hl]
	                      	| [ld   hl,0x07D0]
	move.w	#0x7D0,high_score_880C              	| [ld   (high_score_880C),hl]
	jbsr	init_highscore_table_2540         	| [call init_highscore_table_2540]

	* no cocktail mode support!
	clr.b	cocktail_mode_8818           	| [ld   (cocktail_mode_8818),a]
	clr.b	d0                               	| [ld   a,0x00]
	move.b	d0,game_playing_8817            	| [ld   (game_playing_8817),a]
 * initialize random number generator with 0x365A value
	                      	| [ld   hl,0x365A]
	move.w	#0x365A,random_seed_8826             	| [ld   (random_seed_8826),hl]
	
	* skip some strange memory check / protection
	move.b	#0xFC,weird_variable_882A          	| [ld   (weird_variable_882A),a]

loop_0478:
	                               	| [ld   a,0x00]
	clr.b	currently_playing_8819       	| [ld   (currently_playing_8819),a]
	jbsr	display_thanks_for_playing_04A0   	| [call display_thanks_for_playing_04A0]

 * loop

loop_0480:
	jbsr	display_title_screen_0521         	| [call display_title_screen_0521]
	*jbsr	pack_ice_screen_22CB              	| [call pack_ice_screen_22CB]
	*jbsr	display_demo_and_top_scores_6E1   	| [call display_demo_and_top_scores_6E1]
	move.b	#0x80,d0                        	| [ld   a,0x80]
	jbsr	delay_28D1                        	| [call delay_28D1]
	jeq	loop_0480                          	| [jr   z,loop_0480]
	
coin_has_been_inserted_0490:
	
	bsr		osd_break

display_thanks_for_playing_04A0:
	jbsr	clear_screen_and_colors_28E5      	| [call clear_screen_and_colors_28E5]
	jbsr	clear_sprites_31B7                	| [call clear_sprites_31B7]
	jbsr	update_all_scores_2B10            	| [call update_all_scores_2B10]

	lea	str_thanks_for_playing_try_once_more_4D0(pc),a0                      	| [ld   hl,0x04D0]
	jbsr	print_line_typewriter_style_29F4                   	| [call print_line_typewriter_style_29F4]
	jbsr	print_line_typewriter_style_29F4                   	| [call print_line_typewriter_style_29F4]
	move.b	#0x40,d0                        	| [ld   a,0x40]
	jbsr	delay_28D1                        	| [call delay_28D1]
	jbsr	print_line_typewriter_style_29F4                   	| [call print_line_typewriter_style_29F4]
	move.b	#0xC0,d0                        	| [ld   a,0xC0]
	jbsr	delay_28D1                        	| [call delay_28D1]
	rts   	| [ret]
str_thanks_for_playing_try_once_more_4D0:
     dc.b	0x02,0x0A,0x90,0x20,0x20,0x20,0x20,0x20,0xA0,0x02,0x0D,0x90,0x20,0x20,0x20,0x54   | ......   T
     dc.b	0x48,0x41,0x4E,0x4B,0x53,0x20,0x46,0x4F,0x52,0x20,0x50,0x4C,0x41,0x59,0x49,0x4E   | HANKS FOR PLAYIN
     dc.b	0x47,0x3A,0x20,0xA0,0x02,0x10,0x90,0x20,0x20,0x20,0x20,0x20,0x54,0x52,0x59,0x20   | G:...     TRY
     dc.b	0x4F,0x4E,0x43,0x45,0x20,0x4D,0x4F,0x52,0x45,0x20,0x3D,0x20,0x20,0x20,0x20,0xA0   | ONCE MORE =


display_title_screen_0521:
	clr.b	d0                               	| [ld   a,$00]
	move.b	d0,player_number_8816           	| [ld   (player_number_8816),a]
	jbsr	clear_screen_and_colors_28E5      	| [call clear_screen_and_colors_28E5]
	jbsr	clear_sprites_31B7                	| [call clear_sprites_31B7]
	jbsr	update_all_scores_2B10            	| [call update_all_scores_2B10]
	jbsr	draw_sega_logo_05BE               	| [call draw_sega_logo_05BE]
	lea	squash_snobee_msg_57A(pc),a0       	| [ld   hl,squash_snobee_msg_57A]
	jbsr	print_line_typewriter_style_29F4                   	| [call print_line_typewriter_style_29F4]
	lea	pengo_string_590(pc),a0            	| [ld   hl,pengo_string_590]
	jbsr	print_line_typewriter_style_29F4                   	| [call print_line_typewriter_style_29F4]
	lea	snoobee_string_0598(pc),a0         	| [ld   hl,snoobee_string_0598]
	jbsr	print_line_typewriter_style_29F4                   	| [call print_line_typewriter_style_29F4]
	*move.b	#0x12,d5                        	| [ld   h,$12]
	*move.b	#0x07,d6                        	| [ld   l,$07]
	move.w	#0x0712,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	move.b	#0x09,d0                        	| [ld   a,$09]
	move.b	d0,cursor_color_8802            	| [ld   (cursor_color_8802),a]
	jbsr	draw_ice_block_tile_2EFE          	| [call draw_ice_block_tile_2EFE]
	lea	iceblock_string_05A2(pc),a0        	| [ld   hl,iceblock_string_05A2]
	jbsr	print_line_typewriter_style_29F4                   	| [call print_line_typewriter_style_29F4]
	move.b	#0x16,d1                        	| [ld   b,$16]
	move.b	#0x07,d2                        	| [ld   c,$07]
	move.b	#0x09,d0                        	| [ld   a,$09]
	move.b	d0,cursor_color_8802            	| [ld   (cursor_color_8802),a]
	jbsr	set_diamond_position_2FA9         	| [call set_diamond_position_2FA9]
	lea	diamondblock_string_05AE(pc),a0    	| [ld   hl,diamondblock_string_05AE]
	jbsr	print_line_typewriter_style_29F4                   	| [call print_line_typewriter_style_29F4]
	jbsr	pengo_intermission_or_title_1D29  	| [call pengo_intermission_or_title_1D29]
	rts                                    	| [ret]
squash_snobee_msg_57A:
	.byte	0x05,0x06,0x91,0x53,0x51,0x55,0x41,0x53,0x48,0x20,0x54,0x48,0x45,0x20,0x53,0x4E  |  ...SQUASH THE SNOBEES
	.byte	0x4F,0x3F,0x42,0x45,0x45,0xD3
pengo_string_590:
	.byte	0x0C,0x0B,0x91,0x50,0x45,0x4E,0x47,0xCF   | ...PENG0
snoobee_string_0598:
	.byte	0x0C,0x0F,0x98,0x53,0x4E,0x4F,0x3F,0x42,0x45,0xC5   | .SNO BEE...ICE B
iceblock_string_05A2:
	.byte	0x0C,0x13,0x91,0x49,0x43,0x45,0x20,0x42,0x4C,0x4F,0x43,0xCB
diamondblock_string_05AE:
	.byte	0x0C,0x17,0x98,0x44,0x49,0x41,0x4D,0x4F,0x4E,0x44,0x20,0x42,0x4C,0x4F,0x43,0xCB   | ...DIAMOND BLOCK


draw_sega_logo_05BE:
	                        	| [ld   a,$09]
	move.b	#0x09,cursor_color_8802            	| [ld   (cursor_color_8802),a]
	move.b	#0xF0,d0                        	| [ld   a,$F0]
											| [ld   hl,$1B09]
	move.w	#0x091B,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	jbsr	set_2x2_tile_2F00                 	| [call set_2x2_tile_2F00]
											| [ld   hl,$1B0B]
	move.w	#0x0B1B,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	jbsr	set_2x2_tile_2F00                 	| [call set_2x2_tile_2F00]
											| [ld   hl,$1B0D]
	move.w	#0x0D1B,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	jbsr	set_2x2_tile_2F00                 	| [call set_2x2_tile_2F00]
											| [ld   hl,$1B0F]
	move.w	#0x0F1B,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	jbsr	set_2x2_tile_2F00                 	| [call set_2x2_tile_2F00]
	move.b	#0x9C,d0                        	| [ld   a,$9C]
											| [ld   hl,$1D09]
	move.w	#0x091D,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	jbsr	set_4_consecutive_tiles_in_a_row_060C	| [call set_4_consecutive_tiles_in_a_row_060C]
	move.b	#0x5C,d0                        	| [ld   a,$5C]
	jbsr	set_4_consecutive_tiles_in_a_row_060C	| [call set_4_consecutive_tiles_in_a_row_060C]
												| [ld   hl,$1B11]
	move.w	#0x111B,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	move.b	#0x22,d0                        	| (R) registered char [ld   a,$22]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	addq.b	#1,d0                           	| bottom of (R) char [inc  a]
	jbsr	move_cursor_1_2919        	| [call move_cursor_1_2919]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	rts                                    	| [ret]

set_4_consecutive_tiles_in_a_row_060C:
	move.b	#0x04,d1                        	| [ld   b,$04]
l_060e:
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	addq.b	#1,d0                           	| [inc  a]
	subq.b	#1,d1                           	| [...]
	jne	l_060e                             	| [djnz $060E]
	rts                                    	| [ret]

l_0615:
	clr.b	d0                               	| [ld   a,$00]
	move.b	d0,cursor_color_8802            	| [ld   (cursor_color_8802),a]
	lea	table_0670(pc),a0                  	| [ld   hl,table_0670]
	move.b	#0xA0,d3                        	| [ld   d,$A0]
	move.b	#0x08,d1                        	| [ld   b,$08]
l_0621:
	move.w	d1,-(sp)                        	| [push bc]
	move.b	#0x07,d0                        	| [ld   a,$07]
	sub.b	d1,d0                            	| [sub  b]
	addq.b	#0x02,d0                        	| [add  a,$02]
	move.b	d0,d1                           	| [ld   b,a]
	move.b	#0x05,d2                        	| [ld   c,$05]
	move.b	d2,cursor_x_8800                	| [ld   (cursor_x_8800),bc]
	move.b	d1,cursor_y_8801                	| [ld   (cursor_x_8800),bc]
l_062e:
	move.b	(a0)+,d0                         	| [ld   a,(hl)]
	                           	| [inc  hl]
	                               	| [and  a]
	jeq	l_066c                             	| [jr   z,$066C]
	move.b	d0,d1                           	| [ld   b,a]
	btst.b	#7,d0                           	| [bit  7,a]
	jne	l_0645                             	| [jr   nz,$0645]
	btst.b	#6,d0                           	| [bit  6,a]
	jne	l_0651                             	| [jr   nz,$0651]
l_063c:
	move.b	d3,d0                           	| [ld   a,d]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	addq.b	#1,d3                           	| [inc  d]
	subq.b	#1,d1                           	| [...]
	jne	l_063c                             	| [djnz $063C]
	jra	l_062e                             	| [jr   $062E]
l_0645:
	and.b	#0x0F,d0                         	| [and  $0F]
	move.b	d0,d1                           	| [ld   b,a]
	move.b	#0x20,d0                        	| [ld   a,$20]
l_064a:
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	subq.b	#1,d1                           	| [...]
	jne	l_064a                             	| [djnz $064A]
	jra	l_062e                             	| [jr   $062E]
l_0651:
	and.b	#0x0F,d0                         	| [and  $0F]
	move.l	a0,-(sp)                        	| [push hl]
	move.w	d3,-(sp)                        	| [push de]
	lea	table_0664(pc),a0                  	| [ld   hl,table_0664]
	clr.w	d3                               	| [ld   d,$00]
	move.b	d0,d3                           	| [ld   e,a]
	add.W	d3,a0								| [add hl,de]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.w	(sp)+,d3                        	| [pop  de]
	move.l	(sp)+,a0                        	| [pop  hl]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	jra	l_062e                             	| [jr   $062E]
table_0664:
	.byte	0xA3,0xA8,0xC0,0xCD,0xD3,0xE4,0xE8,0xE9

l_066c:
	move.w	(sp)+,d1                        	| [pop  bc]
	subq.b	#1,d1                           	| [...]
	jne	l_0621                             	| [djnz $0621]
	rts                                    	| [ret]

table_0670:
     .byte	0x06,0x00,0x04,0x41,0x01,0x88,0x03,0x00,0x02,0x41,0x0A,0x40,0x04,0x00,0x01,0x41
     .byte	0x03,0x41,0x03,0x41,0x41,0x02,0x41,0x04,0x00,0x01,0x41,0x41,0x01,0x41,0x01,0x41
     .byte	0x01,0x41,0x01,0x41,0x01,0x41,0x02,0x41,0x41,0x01,0x00,0x01,0x41,0x41,0x01,0x41
     .byte	0x03,0x41,0x03,0x41,0x41,0x02,0x41,0x01,0x00,0x01,0x41,0x02,0x41,0x41,0x06,0x43
     .byte	0x41,0x44,0x02,0x00,0x01,0x42,0x01,0x81,0x46,0x47,0x84,0x02,0x42,0x45,0x01,0x00

increase_counter_0875:
	addq.w	#1,counter_lsb_8824
	rts                                    	| [ret]

* control chars + PLAYER 1
rect_dimensions_FDE:
	dc.b	0x09,0x10,0x00,0x0A,0x05
str_player_1_FE3:
	dc.b	0x0A,0x11,0x10,0x50,0x4C,0x41,0x59,0x45,0x52,0x20,0xB1
str_player_2_FEE:
	dc.b	0x0A,0x11,0x10
	.ascii	"PLAYER "
	dc.b	0xB2		| 2 with bit 7 set
str_ready_FF9:
	dc.b	0x0B,0x13,0x10,0x52,0x45,0x41,0x44,0xD9		| READY
	.align	2
	
	

	
play_sfx_1889:
	move.w	d0,-(sp)
	clr		D0
	move.b	d1,d0
	bsr		osd_sound_start
	move.w	(sp)+,d0
	rts
	

enable_sound_18EC:
	jra		osd_sound_enable

disable_sound_18F2:
	jra		osd_sound_disable

* the main idea of this routine is to move characters automatically
* during non-playing parts of the game
pengo_intermission_or_title_1D29:
	move.b	#0x07,d1                        	| [ld   b,$07]
	jbsr	play_sfx_1889                     	| dance music [call play_sfx_1889]
	move.b	#0x40,d0                        	| [ld   a,$40]
	jbsr	delay_28D1                        	| [call delay_28D1]
	jbsr	init_all_characters_states_1D60   	| [call init_all_characters_states_1D60]
l_1d36:
	jbsr	increase_counter_0875             	| [call increase_counter_0875]
 * small active loop
	clr.b	d1                               	| [ld   b,$00]
l_1d3b:
	subq.b	#1,d1                           	| [...]
	jne	l_1d3b                             	| [djnz $1D3B]


* here we move 6 objects max: 6 pengos, using the ice block
* sprite structure
	jbsr	move_snobee_1_title_1DA2          	| [call move_snobee_1_title_1DA2]
	jbsr	move_snobee_2_title_1DA8          	| 2 [call move_snobee_2_title_1DA8]
	jbsr	move_snobee_3_title_1DAE          	| 3 [call move_snobee_3_title_1DAE]
	jbsr	move_snobee_4_title_1DB4          	| 4 [call move_snobee_4_title_1DB4]
	jbsr	move_character_following_path_1DBA	| pengo [call move_character_following_path_1DBA]
	jbsr	move_character_intermission_path_1DC0	| moving block [call move_character_intermission_path_1DC0]
	lea	moving_block_struct_8DA0(pc),a2    	| [ld   ix,moving_block_struct_8DA0]
	move.b	#0x05,d0                        	| [ld   a,$05]
	cmp.b	(char_state,a2),d0               	| [cp   (ix+char_state)]
	jne	l_1d36                             	| [jr   nz,$1D36]
	move.b	#0x40,d0                        	| [ld   a,$40]
	jbsr	delay_28D1                        	| [call delay_28D1]
	rts                                    	| [ret]

 * init snobees, pengo, and moving block to an empty state (0) and init sprites
 * used for title, intermission and ice pack screens, not in real game
init_all_characters_states_1D60:
	lea	snobee_1_struct_8D00(pc),a2        	| [ld   ix,snobee_1_struct_8D00]
	move.w	#0x20,d3                      	| [ld   de,$0020]
	clr.b	(char_state,a2)                  	| [ld   (ix+char_state),$00]
	move.b	#0x01,(char_id,a2)              	| [ld   (ix+char_id),$01]
	add.w	d3,a2								| [add  ix,de]
	clr.b	(char_state,a2)                  	| [ld   (ix+char_state),$00]
	move.b	#0x02,(char_id,a2)              	| [ld   (ix+char_id),$02]
	add.w	d3,a2								| [add  ix,de]
	clr.b	(char_state,a2)                  	| [ld   (ix+char_state),$00]
	move.b	#0x03,(char_id,a2)              	| [ld   (ix+char_id),$03]
	add.w	d3,a2								| [add  ix,de]
	clr.b	(char_state,a2)                  	| [ld   (ix+char_state),$00]
	move.b	#0x04,(char_id,a2)              	| [ld   (ix+char_id),$04]
	add.w	d3,a2								| [add  ix,de]
	clr.b	(char_state,a2)                  	| [ld   (ix+char_state),$00]
	move.b	#0x05,(char_id,a2)              	| [ld   (ix+char_id),$05]
	add.w	d3,a2								| [add  ix,de]
	clr.b	(char_state,a2)                  	| [ld   (ix+char_state),$00]
	move.b	#0x06,(char_id,a2)              	| [ld   (ix+char_id),$06]
	rts                                    	| [ret]

move_snobee_1_title_1DA2:
	lea	snobee_1_struct_8D00,a2        	| [ld   ix,snobee_1_struct_8D00]
	jra	l_1dc4                             	| [jr   $1DC4]

move_snobee_2_title_1DA8:
	lea	snobee_2_struct_8D20,a2        	| [ld   ix,snobee_2_struct_8D20]
	jra	l_1dc4                             	| [jr   $1DC4]

move_snobee_3_title_1DAE:
	lea	snobee_3_struct_8D40,a2        	| [ld   ix,snobee_3_struct_8D40]
	jra	l_1dc4                             	| [jr   $1DC4]

move_snobee_4_title_1DB4:
	lea	snobee_4_struct_8D60,a2        	| [ld   ix,snobee_4_struct_8D60]
	jra	l_1dc4                             	| [jr   $1DC4]

move_character_following_path_1DBA:
	lea	pengo_struct_8D80,a2           	| [ld   ix,pengo_struct_8D80]
	jra	l_1dc4                             	| [jr   $1DC4]

move_character_intermission_path_1DC0:
	lea	moving_block_struct_8DA0,a2    	| [ld   ix,moving_block_struct_8DA0]

l_1dc4:
	lea	table_1DF9(pc),a1                  	| [ld   de,table_1DF9]
	move.b	currently_playing_8819,d0       	| [ld   a,(currently_playing_8819)]
	tst.b	d0                               	| [and  a]
	jeq	l_1dda                             	| not playing, skip [jr   z,$1DDA]
	jbsr	get_level_number_288F             	| [call get_level_number_288F]
	lea	table_1DE1(pc),a1                  	| [ld   de,table_1DE1]
	cmp.b	#0x0A,d0                         	| [cp   $0A]
	jcs	l_1dda                             	| less than level 10 [jr   c,$1DDA]
* >= level 10
	lea	table_1DED(pc),a1                  	| table for level 10 and more [ld   de,table_1DED]
l_1dda:
	move.b	(char_state,a2),d0              	| get char to know where to jump [ld   a,(ix+char_state)]
	jra	indirect_jump_2D8F                 	| [jp   indirect_jump_2D8F]

do_nothing_1DE0:
	rts                                    	| [ret]

table_1DE1:
	.long	init_characters_for_intermission_1E05
	.long	do_nothing_1DE0
	.long	move_character_intermission_1EC4
	.long	how_to_dance_20DC
	.long	move_character_intermission_1EC4
	.long	do_nothing_1DE0
table_1DED:
	.long	move_during_title_screen_1E54
	.long	do_nothing_1DE0
	.long	move_character_intermission_1F52
	.long	do_nothing_1DE0
	.long	how_to_dance_20DC
	.long	do_nothing_1DE0
table_1DF9:
	.long	change_character_intermission_phase_1E9C
	.long	do_nothing_1DE0
	.long	move_character_intermission_1F90
	.long	move_character_intermission_204E
	.long	do_nothing_1DE0
	.long	do_nothing_1DE0


init_characters_for_intermission_1E05:
	clr.b	(x_pos,a2)                       	| left [ld   (ix+x_pos),$00]
	move.b	#0x98,(y_pos,a2)                	| center [ld   (ix+y_pos),$98]
	move.b	#0x08,(animation_frame,a2)      	| [ld   (ix+animation_frame),$08]
	move.b	(char_id,a2),d0                 	| [ld   a,(ix+char_id)]
*  differently colored pengos: yellow, cyan, yellow, pink, yellow
	addq.b	#2,d0                           	| [inc  a]
												| [inc  a]
	move.b	d0,(char_color,a2)              	| [ld   (ix+char_color),a]
	jbsr	init_characters_for_auto_mode_1E26	| [call init_characters_for_auto_mode_1E26]
	move.b	(char_id,a2),d0                 	| [ld   a,(ix+char_id)]
	cmp.b	#0x01,d0                         	| [cp   $01]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	rts                                
	
init_characters_for_auto_mode_1E26:
	move.b	#0x03,(facing_direction,a2)     	| [ld   (ix+facing_direction),$03]
	move.b	#0x0A,(instant_move_period,a2)  	| [ld   (ix+instant_move_period),$0A]
	clr.b	(current_period_counter,a2)      	| [ld   (ix+current_period_counter),$00]
	move.b	#0xFF,(0x08,a2)                 	| [ld   (ix+$08),$FF]
	clr.b	(0x09,a2)                        	| [ld   (ix+$09),$00]
	clr.b	(stunned_push_block_counter,a2)  	| [ld   (ix+stunned_push_block_counter),$00]
	clr.b	(0x0b,a2)                        	| [ld   (ix+$0b),$00]
	jbsr	get_level_number_288F             	| [call get_level_number_288F]
	ror.b	#1,d0                            	| [rrca]
	subq.b	#1,d0                           	| [dec  a]
	move.b	d0,(ai_mode,a2)                 	| set mode as level number / 2:	level 16: hardest hunt mode [ld   (ix+ai_mode),a]
	jbsr	display_character_sprite_39AB     	| [call display_character_sprite_39AB]
	jbsr	display_snobee_sprite_33CE        	| [call display_snobee_sprite_33CE]
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	rts                                    	| [ret]

move_during_title_screen_1E54:
	lea	table_1E84(pc),a0                  	| [ld   hl,table_1E84]
	jbsr	next_auto_move_1E64               	| [call next_auto_move_1E64]
	move.b	(char_id,a2),d0                 	| [ld   a,(ix+char_id)]
	cmp.b	#0x01,d0                         	| [cp   $01]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	rts                                    	| [ret]

next_auto_move_1E64:
	move.b	(char_id,a2),d0                 	| [ld   a,(ix+char_id)]
	subq.b	#1,d0                           	| [dec  a]
	rol.b	#2,d0                            	| [rlca]
	                            	| [rlca]
	clr.b	d3                               	| [ld   d,$00]
	move.b	d0,d3                           	| [ld   e,a]
	add.w	d3,a0						| [add hl,de]
											| [ld   a,(hl)]
											| [inc  hl]
	move.b	(a0)+,(x_pos,a2)                   	| [ld   (ix+x_pos),a]
												| [ld   a,(hl)]
												| [inc  hl]
	move.b	(a0)+,(y_pos,a2)                   	| [ld   (ix+y_pos),a]
	                      	| [ld   a,(hl)]
	                          	| [inc  hl]
	move.b	(a0)+,(animation_frame,a2)         	| [ld   (ix+animation_frame),a]
	move.b	(a0)+,d0                         	| [ld   a,(hl)]
												| [inc  hl]
	move.b	d0,(char_color,a2)              	| [ld   (ix+char_color),a]
	jra	init_characters_for_auto_mode_1E26               	| [jr   $1E26]


table_1E84:
	.byte	0x00,0x98,0x08,0x09,0x70,0x88,0x70,0x10,0x80,0x88,0x70
	.byte	0x10,0x70,0x98,0x70,0x10,0x80,0x98,0x70,0x10,0x70,0x90,0xF0,0x0B
	


change_character_intermission_phase_1E9C:
	lea	table_1EAC(pc),a0                  	| [ld   hl,table_1EAC]
	jbsr	next_auto_move_1E64               	| [call next_auto_move_1E64]
	move.b	(char_id,a2),d0                 	| [ld   a,(ix+char_id)]
	cmp.b	#0x04,d0                         	| [cp   $04]
	bcs.b	0f
	rts                                    	| [ret  nc]
0:
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	rts                                    	| [ret]

table_1EAC:
	.byte	0x00,0x28,0x08,0x0A,0x00,0x50,0x08,0x0B,0x00,0x70,0x08,0x01,0x00,0x08,0x08,0x0B
	.byte	0x00,0x18,0x08,0x0D,0x00,0x38,0x08,0x0C

move_character_intermission_1EC4:
	jbsr	animate_intermission_penguins_1ef0	| [call animate_intermission_penguins_1ef0]
	addq.b	#1,(current_period_counter,a2)  	| [inc  (ix+current_period_counter)]
	move.b	(current_period_counter,a2),d0  	| [ld   a,(ix+current_period_counter)]
	cmp.b	(instant_move_period,a2),d0      	| [cp   (ix+instant_move_period)]
	bcc.b	0f
	rts                                    	| [ret  c]
0:
	clr.b	(current_period_counter,a2)      	| [ld   (ix+current_period_counter),$00]
	move.b	#0x18,d0                        	| [ld   a,$18]
	cmp.b	(x_pos,a2),d0                    	| [cp   (ix+x_pos)]
	bne	0f
	jbsr	l_1f17                            	| [call z,$1F17]
0:
	move.b	#0xB0,d0                        	| [ld   a,$B0]
	cmp.b	(x_pos,a2),d0                    	| [cp   (ix+x_pos)]
	bne	0f
	jbsr	l_1f24                            	| [call z,$1F24]
0:
	move.b	#0xF0,d0                        	| [ld   a,$F0]
	cmp.b	(x_pos,a2),d0                    	| [cp   (ix+x_pos)]
	bne	0f
	jbsr	l_1f4e                            	| [call z,$1F4E]
0:
	jra	move_character_according_to_direction_3DD7	| [jp   move_character_according_to_direction_3DD7]

animate_intermission_penguins_1ef0:
	move.b	counter_lsb_8824,d0             	| [ld   a,(counter_lsb_8824)]
	and.b	#0x1F,d0                         	| [and  $1F]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
 * counter 1 out of 32 xxx
	clr.b	d1                               	| [ld   b,$00]
	move.b	(char_state,a2),d0              	| [ld   a,(ix+char_state)]
	cmp.b	#0x04,d0                         	| [cp   $04]
	jne	l_1f08                             	| [jr   nz,$1F08]
* this is reached only when penguins dance during the intermission
	move.b	(ai_mode,a2),d0                 	| [ld   a,(ix+ai_mode)]
	cmp.b	#0x03,d0                         	| [cp   $03]
	jne	l_1f08                             	| [jr   nz,$1F08]
	move.b	#0x3A,d1                        	| [ld   b,$3A]
l_1f08:
	addq.b	#1,(alive_walk_counter,a2)      	| [inc  (ix+alive_walk_counter)]
	move.b	(alive_walk_counter,a2),d0      	| [ld   a,(ix+alive_walk_counter)]
	and.b	#0x03,d0                         	| [and  $03]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	addq.b	#1,(alive_walk_counter,a2)      	| [inc  (ix+alive_walk_counter)]
	jra	l_3985                             	| [jp   $3985]

l_1f17:
	move.l	a2,-(sp)                        	| [push ix]
	move.w	#0x20,d3                      	| [ld   de,$0020]
	add.w	d3,a2							| [add  ix,de]
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	move.l	(sp)+,a2                        	| [pop  ix]
	rts                                    	| [ret]
l_1f24:
	move.b	(char_id,a2),d0                 	| [ld   a,(ix+char_id)]
	cmp.b	#0x01,d0                         	| [cp   $01]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	move.l	a2,-(sp)                        	| [push ix]
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	move.w	#0x20,d3                      	| [ld   de,$0020]
	add.w	d3,a2							| [add  ix,de]
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	add.w	d3,a2							| [add  ix,de]
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	add.w	d3,a2							| [add  ix,de]
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	add.w	d3,a2							| [add  ix,de]
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	add.w	d3,a2							| [add  ix,de]
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	move.l	(sp)+,a2                        	| [pop  ix]
	rts                                    	| [ret]

l_1f4e:
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	rts                                    	| [ret]

move_character_intermission_1F52:
	move.b	(char_id,a2),d0                 	| [ld   a,(ix+char_id)]
	cmp.b	#0x01,d0                         	| [cp   $01]
	bne	0f
	jbsr	animate_intermission_penguins_1ef0	| [call z,animate_intermission_penguins_1ef0]
0:
	addq.b	#1,(current_period_counter,a2)  	| [inc  (ix+current_period_counter)]
	move.b	(current_period_counter,a2),d0  	| [ld   a,(ix+current_period_counter)]
	cmp.b	(instant_move_period,a2),d0      	| [cp   (ix+instant_move_period)]
	bcc.b	0f
	rts                                    	| [ret  c]
0:
	clr.b	(current_period_counter,a2)      	| [ld   (ix+current_period_counter),$00]
	move.b	#0x60,d0                        	| [ld   a,$60]
	cmp.b	(x_pos,a2),d0                    	| [cp   (ix+x_pos)]
	jne	0f
	jbsr	l_1f7b                            	| [call z,$1F7B]
0:
	move.b	#0xF0,d0                        	| [ld   a,$F0]
	cmp.b	(x_pos,a2),d0                    	| [cp   (ix+x_pos)]
	jne	0f
	jbsr	l_1f4e                            	| [call z,$1F4E]
0:
	jra	move_character_according_to_direction_3DD7	| [jp   move_character_according_to_direction_3DD7]
l_1f7b:
	jbsr	l_1f24                            	| [call $1F24]
	move.l	a2,-(sp)                        	| [push ix]
	lea	moving_block_struct_8DA0(pc),a2    	| [ld   ix,moving_block_struct_8DA0]
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	move.l	(sp)+,a2                        	| [pop  ix]
	subq.b	#1,(char_state,a2)              	| [dec  (ix+char_state)]
	rts                                    	| [ret]
	
move_character_intermission_1F90:
	jbsr	l_1fe4                            	| [call $1FE4]
	addq.b	#1,(current_period_counter,a2)  	| [inc  (ix+current_period_counter)]
	move.b	(current_period_counter,a2),d0  	| [ld   a,(ix+current_period_counter)]
	cmp.b	(instant_move_period,a2),d0      	| [cp   (ix+instant_move_period)]
	bcc.b	0f
	rts                                    	| [ret  c]
0:
	clr.b	(current_period_counter,a2)      	| [ld   (ix+current_period_counter),$00]
	jbsr	l_1fc5                            	| [call $1FC5]
	st.b	d0                                	| [ld   a,$FF]
	cmp.b	(x_pos,a2),d0                    	| [cp   (ix+x_pos)]
	bne	0f
	jbsr	change_last_3_characters_char_states_200a                            	| [call z,$200A]
0:
	move.b	#0x48,d0                        	| [ld   a,$48]
	cmp.b	(x_pos,a2),d0                    	| [cp   (ix+x_pos)]
	jne	0f
	jbsr	l_2032                            	| [call z,$2032]
0:
	lea	table_1FF7(pc),a0                  	| [ld   hl,table_1FF7]
	move.b	(x_pos,a2),d0                   	| [ld   a,(ix+x_pos)]
	move.w	#0x13,d1	                      	| [ld   bc,$0013]
	jbsr	cpir                              	| [cpir]
	bne	0f
	jbsr	l_203d                            	| [call z,$203D]
0:
	jra	move_character_according_to_direction_3DD7	| [jp   move_character_according_to_direction_3DD7]

l_1fc5:
	move.b	(char_id,a2),d0                 	| [ld   a,(ix+char_id)]
	cmp.b	#0x01,d0                         	| [cp   $01]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	move.b	(x_pos,a2),d0                   	| [ld   a,(ix+x_pos)]
	and.b	#0x07,d0                         	| [and  $07]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	move.b	#0x16,d1                        	| [ld   b,$16]
	move.b	#0x07,d2                        	| [ld   c,$07]
	btst.b	#3,(x_pos,a2)                   	| [bit  3,(ix+x_pos)]
	jeq	l_1fe0                             	| [jr   z,$1FE0]
	jbsr	set_2x2_tile_color_0C_4BC2        	| [call set_2x2_tile_color_0C_4BC2]
	jra	l_1fe3                             	| [jr   $1FE3]
l_1fe0:
	jbsr	set_2x2_tile_color_09_4BD8        	| [call set_2x2_tile_color_09_4BD8]
l_1fe3:
	rts                                    	| [ret]

l_1fe4:
	move.b	(char_id,a2),d0                 	| [ld   a,(ix+char_id)]
	cmp.b	#0x02,d0                         	| [cp   $02]
	jeq	animate_intermission_penguins_1ef0 	| [jp   z,animate_intermission_penguins_1ef0]
	move.b	counter_lsb_8824,d0             	| [ld   a,(counter_lsb_8824)]
	and.b	#0x1F,d0                         	| [and  $1F]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
 * counter 1 out of 32 xxx
	move.b	#0x12,d1                        	| [ld   b,$12]
	jra	l_1f08                             	| [jp   $1F08]
table_1FF7:
	.byte	0x38,0x40,0x48,0x50,0x58,0x60,0x68,0x70,0x78,0x80,0x88,0x90,0x98,0xA0,0xA8,0xB0
	.byte	0xB8,0xC0,0xC8
	.align	2


change_last_3_characters_char_states_200a:
	move.l	a2,-(sp)                        	| [push ix]
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	lea	snobee_4_struct_8D60(pc),a2        	| [ld   ix,snobee_4_struct_8D60]
	move.w	#0x20,d3                      	| [ld   de,$0020]
	addq.b	#2,(char_state,a2)              	| [inc  (ix+char_state)]
												| [inc  (ix+char_state)]
	add.w	d3,a2								| [add  ix,de]
	addq.b	#2,(char_state,a2)              	| [inc  (ix+char_state)]
							| [inc  (ix+char_state)]
	add.w	d3,a2								| [add  ix,de]
	addq.b	#2,(char_state,a2)              	| [inc  (ix+char_state)]
										| [inc  (ix+char_state)]
	move.l	(sp)+,a2                        	| [pop  ix]
	jra	l_0615                            	| [call $0615]
	rts                                    	| [ret]
l_2032:
	move.b	(char_id,a2),d0                 	| [ld   a,(ix+char_id)]
	cmp.b	#0x01,d0                         	| [cp   $01]
	bne.b	0f
	rts                                    	| [ret  z]
0:
	cmp.b	#0x04,d0                         	| [cp   $04]
	bcs.b	0f
	rts                                    	| [ret  nc]
0:
	move.l	(sp)+,a0                        	| [pop  hl]
	rts                                    	| [ret]
	
l_203d:
	ror.b	#3,d0                            	| [rrca]
	and.b	#0x1F,d0                         	| [and  $1F]
	subq.b	#0x02,d0                        	| [sub  $02]
	move.b	d0,d6                           	| [ld   l,a]
	move.b	#0x06,d5                        	| [ld   h,$06]
	move.b	d6,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	move.b	d5,cursor_y_8801                	| [ld   (cursor_x_8800),hl]
	jbsr	put_blank_at_current_pos_2900     	| [call put_blank_at_current_pos_2900]
	rts                                    	| [ret]

move_character_intermission_204E:
	jbsr	l_1fe4                            	| [call $1FE4]
	addq.b	#1,(current_period_counter,a2)  	| [inc  (ix+current_period_counter)]
	move.b	(current_period_counter,a2),d0  	| [ld   a,(ix+current_period_counter)]
	cmp.b	(instant_move_period,a2),d0      	| [cp   (ix+instant_move_period)]
	bcc.b	0f
	rts                                    	| [ret  c]
0:
	clr.b	(current_period_counter,a2)      	| [ld   (ix+current_period_counter),$00]
	jbsr	l_1fc5                            	| [call $1FC5]
	move.b	(x_pos,a2),d0                   	| [ld   a,(ix+x_pos)]
	and.b	#0x07,d0                         	| [and  $07]
	bne	0f
	jbsr	l_20a4                            	| [call z,$20A4]
0:
	move.b	(x_pos,a2),d0                   	| [ld   a,(ix+x_pos)]
	cmp.b	#0x69,d0                         	| [cp   $69]
	bne	0f
	jbsr	l_2085                            	| [call z,$2085]
0:
	move.b	(x_pos,a2),d0                   	| [ld   a,(ix+x_pos)]
	cmp.b	#0x28,d0                         	| [cp   $28]
	bne	0f
	jbsr	l_2093                            	| [call z,$2093]
0:
	move.b	(x_pos,a2),d0                   	| [ld   a,(ix+x_pos)]
	cmp.b	#0xF8,d0                         	| [cp   $F8]
	bne	0f
	jbsr	l_2098                            	| [call z,$2098]
0:
	jra	move_character_according_to_direction_3DD7	| [jp   move_character_according_to_direction_3DD7]

l_2085:
	move.b	(0x09,a2),d0                    	| [ld   a,(ix+$09)]
	tst.b	d0                               	| [and  a]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	move.b	#0x02,(facing_direction,a2)     	| [ld   (ix+facing_direction),$02]
	move.b	#0xFF,(0x09,a2)                 	| [ld   (ix+$09),$FF]
	rts                                    	| [ret]

l_2093:
	move.b	#0x03,(facing_direction,a2)     	| [ld   (ix+facing_direction),$03]
	rts                                    	| [ret]

l_2098:
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	move.b	(char_id,a2),d0                 	| [ld   a,(ix+char_id)]
	cmp.b	#0x06,d0                         	| [cp   $06]
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	rts                                    	| [ret]

l_20a4:
	move.b	(x_pos,a2),d0                   	| [ld   a,(ix+x_pos)]
	ror.b	#3,d0                            	| [rrca]
	and.b	#0x1F,d0                         	| [and  $1F]
	subq.b	#0x01,d0                        	| [sub  $01]
	cmp.b	#0x03,d0                         	| [cp   $03]
	bcc.b	0f
	rts                                    	| [ret  c]
0:
	cmp.b	#0x18,d0                         	| [cp   $18]
	bcs.b	0f
	rts                                    	| [ret  nc]
0:
	move.b	d0,d6                           	| [ld   l,a]
	move.b	#0x01,d5                        	| [ld   h,$01]
	move.b	d6,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	move.b	d5,cursor_y_8801                	| [ld   (cursor_x_8800),hl]
	move.b	#0x0E,d0                        	| [ld   a,$0E]
	btst.b	#0,(facing_direction,a2)        	| [bit  0,(ix+facing_direction)]
	jne	l_20c4                             	| [jr   nz,$20C4]
	clr.b	d0                               	| [ld   a,$00]
l_20c4:
	move.b	#0x08,d1                        	| [ld   b,$08]
l_20c6:
	move.w	d1,-(sp)                        	| [push bc]
	jbsr	set_attribute_at_current_pos_292D 	| [call set_attribute_at_current_pos_292D]
	jbsr	move_cursor_1_2919                	| [call move_cursor_1_2919]
	move.w	(sp)+,d1                        	| [pop  bc]
	subq.b	#1,d1                           	| [...]
	jne	l_20c6                             	| [djnz $20C6]
	rts                                    	| [ret]

select_proper_jump_table_20D1:
	clr.w	d6                               	| [ld   h,$00]
	move.b	(ai_mode,a2),d6                 	| [ld   l,(ix+ai_mode)]
	add.w	d6,d6								| [add hl,hl]
	add.w	d6,d6								|
												| [add  hl,de]
	move.l	(a1,d6.w),a1                         	| [ld   e,(hl)]
											| [inc  hl]
										| [ld   d,(hl)]
	rts                                    	| [ret]

how_to_dance_20DC:
	lea	jump_table_table_20E8(pc),a1       	| [ld   de,jump_table_table_20E8]
	jbsr	select_proper_jump_table_20D1     	| [call select_proper_jump_table_20D1]
	move.b	(intermission_dance_counter,a2),d0	| [ld   a,(ix+intermission_dance_counter)]
	jra	indirect_jump_2D8F                 	| [jp   indirect_jump_2D8F]

jump_table_table_20E8:
	.long	jump_table_20F8
	.long	jump_table_214C
	.long	jump_table_2180
	.long	jump_table_21B8
	.long	jump_table_21CC
	.long	jump_table_2265
	.long	jump_table_21CC
	.long	jump_table_2265

jump_table_20F8:
	.long	l_2130
	.long	l_3ffa
	.long	l_406e
	.long	l_401f
	.long	l_406e
	.long	l_3ffa
	.long	l_406e
	.long	l_401f
	.long	l_406e
	.long	l_2138
	.long	l_3ffa
	.long	l_406e
	.long	l_401f
	.long	l_406e
	.long	l_3ffa
	.long	l_406e
	.long	l_401f
	.long	l_406e
	.long	l_2140
	.long	l_3ffa
	.long	l_406e
	.long	l_401f
	.long	l_406e
	.long	l_3ffa
	.long	l_406e
	.long	l_401f
	.long	l_406e
	.long	l_2148


l_2130:
	move.b	#0x01,(facing_direction,a2)     	| [ld   (ix+facing_direction),$01]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]

l_2138:
	move.b	#0x02,(facing_direction,a2)     	| [ld   (ix+facing_direction),$02]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]

l_2140:
	move.b	#0x03,(facing_direction,a2)     	| [ld   (ix+facing_direction),$03]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]

l_2148:
	addq.b	#1,(char_state,a2)              	| [inc  (ix+char_state)]
	rts                                    	| [ret]

jump_table_214C:
	.long	l_2140
	.long	l_3ffa
	.long	l_406e
	.long	l_401f
	.long	l_406e
	.long	l_3ffa
	.long	l_406e
	.long	l_401f
	.long	l_406e
	.long	l_2170
	.long	l_406e
	.long	l_217c
	.long	l_406e
	.long	l_2170
	.long	l_406e
	.long	l_217c
	.long	l_406e


l_2170:
	move.b	#0x78,d1                        	| [ld   b,$78]
l_2172:
	move.b	d1,(animation_frame,a2)         	| [ld   (ix+animation_frame),b]
	jbsr	display_character_sprite_39AB     	| [call display_character_sprite_39AB]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]
l_217c:
	move.b	#0x7C,d1                        	| [ld   b,$7C]
	jra	l_2172                             	| [jr   $2172]

jump_table_2180:
	.long	l_218e
	.long	l_21a2
	.long	l_218e
	.long	l_21ad
	.long	l_218e
	.long	l_2140
	.long	l_2148


l_218e:
	btst.b	#0,(0x09,a2)                    	| [bit  0,(ix+$09)]
	bne	0f
	jbsr	l_2199                            	| [call z,$2199]
0:
	jbsr	l_4082                            	| [call $4082]
	rts                                    	| [ret]

l_2199:
	move.b	#0x0A,(stunned_push_block_counter,a2)	| [ld   (ix+stunned_push_block_counter),$0A]
	move.b	#0x0F,(0x09,a2)                 	| [ld   (ix+$09),$0F]
	rts                                    	| [ret]

l_21a2:
	move.b	#0x94,(animation_frame,a2)      	| [ld   (ix+animation_frame),$94]
	jbsr	display_character_sprite_39AB     	| [call display_character_sprite_39AB]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]

l_21ad:
	move.b	#0x12,(animation_frame,a2)      	| [ld   (ix+animation_frame),$12]
	jbsr	display_character_sprite_39AB     	| [call display_character_sprite_39AB]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]

jump_table_21B8:
	.long	l_218e
	.long	l_2130
	.long	l_218e
	.long	l_2140
	.long	l_21c4
	.long	l_2148

l_21c4:
	clr.b	(alive_walk_counter,a2)          	| [ld   (ix+alive_walk_counter),$00]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]

* 32 values
jump_table_21CC:
	.long	l_2240
	.long	l_218e
	.long	l_220c
	.long	l_406e
	.long	l_221b
	.long	l_406e
	.long	l_220c
	.long	l_406e
	.long	l_221b
	.long	l_218e
	.long	l_220c
	.long	l_406e
	.long	l_221b
	.long	l_406e
	.long	l_220c
	.long	l_406e
	.long	l_221b
	.long	l_218e
	.long	l_218e
	.long	l_222a
	.long	l_218e
	.long	l_2235
	.long	l_220c
	.long	l_406e
	.long	l_221b
	.long	l_406e
	.long	l_220c
	.long	l_406e
	.long	l_221b
	.long	l_218e
	.long	l_2297
	.long	l_2148

l_220c:
	move.b	#0x72,(x_pos,a2)                	| [ld   (ix+x_pos),$72]
	move.b	#0x92,(y_pos,a2)                	| [ld   (ix+y_pos),$92]
	jbsr	display_snobee_sprite_33CE        	| [call display_snobee_sprite_33CE]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]

l_221b:
	move.b	#0x70,(x_pos,a2)                	| [ld   (ix+x_pos),$70]
	move.b	#0x90,(y_pos,a2)                	| [ld   (ix+y_pos),$90]
	jbsr	display_snobee_sprite_33CE        	| [call display_snobee_sprite_33CE]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]
l_222a:
	move.b	#0xF4,(animation_frame,a2)      	| [ld   (ix+animation_frame),$F4]
	jbsr	display_character_sprite_39AB     	| [call display_character_sprite_39AB]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]
l_2235:
	move.b	#0xF0,(animation_frame,a2)      	| [ld   (ix+animation_frame),$F0]
	jbsr	display_character_sprite_39AB     	| [call display_character_sprite_39AB]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]

l_2240:
												| [ld   h,$13]
												| [ld   l,$0C]
	move.w	#0x0C13,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	move.b	#0x12,d0                        	| [ld   a,$12]
	move.b	d0,cursor_color_8802            	| [ld   (cursor_color_8802),a]
	move.b	#0x90,d0                        	| [ld   a,$90]
	move.b	#0x04,d1                        	| [ld   b,$04]
l_2250:
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	addq.b	#1,d0                           	| [inc  a]
	subq.b	#1,d1                           	| [...]
	jne	l_2250                             	| [djnz $2250]
	jbsr	move_cursor_4_2923                	| [call move_cursor_4_2923]
	move.b	#0x04,d1                        	| [ld   b,$04]
l_225b:
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	addq.b	#1,d0                           	| [inc  a]
	subq.b	#1,d1                           	| [...]
	jne	l_225b                             	| [djnz $225B]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]


jump_table_2265:
	.long	l_2240
	.long	l_2297
	.long	l_218e
	.long	l_218e
	.long	l_218e
	.long	l_22a6
	.long	l_22b5
	.long	l_406e
	.long	l_22c0
	.long	l_406e
	.long	l_22b5
	.long	l_406e
	.long	l_2297
	.long	l_218e
	.long	l_218e
	.long	l_22a6
	.long	l_22b5
	.long	l_406e
	.long	l_22c0
	.long	l_218e
	.long	l_218e
	.long	l_22b5
	.long	l_406e
	.long	l_2297
	.long	l_2148

l_2297:
	clr.b	(x_pos,a2)                       	| [ld   (ix+x_pos),$00]
	clr.b	(y_pos,a2)                       	| [ld   (ix+y_pos),$00]
	jbsr	display_snobee_sprite_33CE        	| [call display_snobee_sprite_33CE]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]

l_22a6:
	move.b	#0x7E,(x_pos,a2)                	| [ld   (ix+x_pos),$7E]
	move.b	#0x88,(y_pos,a2)                	| [ld   (ix+y_pos),$88]
	jbsr	display_snobee_sprite_33CE        	| [call display_snobee_sprite_33CE]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]

l_22b5:
	move.b	#0xE8,(animation_frame,a2)      	| [ld   (ix+animation_frame),$E8]
	jbsr	display_character_sprite_39AB     	| [call display_character_sprite_39AB]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]
l_22c0:
	move.b	#0xEC,(animation_frame,a2)      	| [ld   (ix+animation_frame),$EC]
	jbsr	display_character_sprite_39AB     	| [call display_character_sprite_39AB]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]

* set default hiscores all to 20000
* (would be a good location to load highscores)
init_highscore_table_2540:
	move.w	#0x7D0,d0                      	| 20000 [ld   hl,0x07D0]
	move.w	d0,hiscore_pos_5_8840+0x18      	| best score [ld   (hiscore_pos_5_8840+0x18),hl]
	move.w	d0,hiscore_pos_5_8840+0x12      	| 2nd score [ld   (hiscore_pos_5_8840+0x12),hl]
	move.w	d0,hiscore_pos_5_8840+0xC       	| ... [ld   (hiscore_pos_5_8840+0xC),hl]
	move.w	d0,hiscore_pos_5_8840+6         	| [ld   (hiscore_pos_5_8840+6),hl]
	move.w	d0,hiscore_pos_5_8840           	| [ld   (hiscore_pos_5_8840),hl]
* set text attributes for names
	lea	high_score_names_8842(pc),a0       	| [ld   hl,high_score_names_8842]
	move.b	#0x01,d0                        	| [ld   a,0x01]
	move.b	#0x05,d1                        	| [ld   b,0x05]
l_255c:
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.w	#6,a0
	subq.b	#1,d1                           	| [...]
	jne	l_255c                             	| [djnz 0x255C]
* set default names (AKIRA)
	lea	hiscore_pos_5_8840+0x18+3(pc),a0   	| [ld   hl,hiscore_pos_5_8840+0x18+3]
	move.b	#0x41,d0                        	| AAA [ld   a,0x41]
	jbsr	set_3_chars_2589                  	| [call set_3_chars_2589]
	lea	hiscore_pos_5_8840+0x12+3(pc),a0   	| [ld   hl,hiscore_pos_5_8840+0x12+3]
	move.b	#0x4B,d0                        	| KKK [ld   a,0x4B]
	jbsr	set_3_chars_2589                  	| [call set_3_chars_2589]
	lea	hiscore_pos_5_8840+0xC+3(pc),a0    	| [ld   hl,hiscore_pos_5_8840+0xC+3]
	move.b	#0x49,d0                        	| III [ld   a,0x49]
	jbsr	set_3_chars_2589                  	| [call set_3_chars_2589]
	lea	hiscore_pos_5_8840+9(pc),a0        	| [ld   hl,hiscore_pos_5_8840+9]
	move.b	#0x52,d0                        	| RRR [ld   a,0x52]
	jbsr	set_3_chars_2589                  	| [call set_3_chars_2589]
	lea	hiscore_pos_5_8840+3(pc),a0        	| [ld   hl,hiscore_pos_5_8840+3]
	move.b	#0x41,d0                        	| AAA [ld   a,0x41]
	jbsr	set_3_chars_2589                  	| [call set_3_chars_2589]
	rts                                    	| [ret]

set_3_chars_2589:
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	rts                                    	| [ret]

get_level_number_288F:
	lea	level_number_player1_8812,a0   	| [ld   hl,level_number_player1_8812]
	move.b	player_number_8816,d0           	| [ld   a,(player_number_8816)]
	btst.b	#0,d0                           	| [bit  0,a]
	jeq	l_289c                             	| [jr   z,$289C]
	lea	level_number_player2_8813,a0   	| [ld   hl,level_number_player2_8813]
l_289c:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	rts                                    	| [ret]

get_nb_lives_289E:
	lea	lives_counter_p1_8814,a0       	| [ld   hl,lives_counter_p1_8814]
	move.b	player_number_8816,d0           	| [ld   a,(player_number_8816)]
	btst.b	#0,d0                           	| [bit  0,a]
	jeq	l_28ab                             	| [jr   z,$28AB]
	lea	lives_counter_p2_8815,a0       	| [ld   hl,lives_counter_p2_8815]
l_28ab:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x7F,d0                         	| [and  $7F]
	rts                        

 * a:	value to wait (1 = 1/5th of seconds roughly speaking)
delay_28D1:
	move.b	d0,delay_timer_8820             	| [ld   (delay_timer_8820),a]
l_28d4:
	move.b	delay_timer_8820,d0             	| [ld   a,(delay_timer_8820)]
	tst.b	d0                               	| [and  a]
	jne	l_28d4                             	| [jr   nz,0x28D4]
	rts                                    	| [ret]


clear_screen_and_colors_28E5:
	* not very useful to transcode that part. Just re-code it
	move.w	#0x8000,d6
	move.w	#0x3FF,d1
	move.b	#0x20,d0
0:
	jbsr	osd_w_videoram
	addq.w	#1,d6
	dbf		d1,0b
* same thing with attributes
	move.w	#0x3FF,d1
	clr		d0
0:
	jbsr	osd_w_colorram
	addq.w	#1,d6
	dbf		d1,0b
	rts


put_blank_at_current_pos_2900:
	move.w	d0,-(sp)                        	| [push af]
	move.b	#0x20,d0                        	| [ld   a,$20]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	move.w	(sp)+,d0                        	| [pop  af]
	rts                                    	| [ret]
move_cursor_b_290B:
	move.w	d0,-(sp)                        	| [push af]
	move.l	a0,-(sp)                        	| [push hl]
	lea	cursor_x_8800(pc),a0               	| [ld   hl,cursor_x_8800]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	sub.b	d1,d0                            	| [sub  b]
	move.b	d0,(a0)+                         	| [ld   (hl),a]
										| [inc  hl]
	addq.b	#1,(a0)                         	| [inc  (hl)]
	move.l	(sp)+,a0                        	| [pop  hl]
	move.w	(sp)+,d0                        	| [pop  af]
	move.w	(sp)+,d1                        	| [pop  bc]
	rts                                    	| [ret]


move_cursor_1_2919:
	move.w	d1,-(sp)                        	| [push bc]
	move.b	#0x01,d1                        	| [ld   b,$01]
	jra	move_cursor_b_290B         	| [jr   move_cursor_b_290B]

move_cursor_2_291E:
	move.w	d1,-(sp)                        	| [push bc]
	move.b	#0x02,d1                        	| [ld   b,$02]
	jra	move_cursor_b_290B         	| [jr   move_cursor_b_290B]

move_cursor_4_2923:
	move.w	d1,-(sp)                        	| [push bc]
	move.b	#0x04,d1                        	| [ld   b,$04]
	jra	move_cursor_b_290B         	| [jr   move_cursor_b_290B]

move_cursor_1A_2928:
	move.w	d1,-(sp)                        	| [push bc]
	move.b	#0x1A,d1                        	| [ld   b,$1A]
	jra	move_cursor_b_290B         	| [jr   move_cursor_b_290B]

* < A: attribute code to put at current screen address
* (doesn't write at this address but in attributes at +0x400)
* updates current position

set_attribute_at_current_pos_292D:
	movem.w	d0-d3,-(sp)                        	| [push af]
	                     	| [push bc]
	                     	| [push bc]
	                     	| [push de]
	move.l	a0,-(sp)                        	| [push hl]
	move.w	d0,-(sp)                        	| [push af]
	move.b	cursor_x_8800,D2            	| get current X & Y [ld   bc,(cursor_x_8800)]
	move.b	cursor_y_8801,D1            	| get current X & Y [ld   bc,(cursor_x_8800)]
	jbsr	convert_coords_to_screen_address_296F	| [call convert_coords_to_screen_address_296F]
	move.w	(sp)+,d0                        	| [pop  af]
	jra	l_294f                             	| [jr   0x294F]

* < A: tile code to put at current screen address with current color
* updates current position

set_tile_at_current_pos_293C:
	movem.w	d0-d3,-(sp)                        	| store a lot of registers :) [push af]
											| [push bc]
											| [push bc]
											| [push de]
	move.l	a0,-(sp)                        	| [push hl]
	move.w	d0,-(sp)                        	| save A again [push af]
	move.b	cursor_x_8800,D2            	| get current X & Y [ld   bc,(cursor_x_8800)]
	move.b	cursor_y_8801,D1            	| get current X & Y [ld   bc,(cursor_x_8800)]
	jbsr	convert_coords_to_screen_address_296F	| convert to address in HL [call convert_coords_to_screen_address_296F]
	move.w	(sp)+,d0                        	| restore A [pop  af]
	jbsr	osd_w_videoram                    	| put value of A at screen XY [ld   (hl),a]
	move.b	cursor_color_8802,d0            	| get current attribute [ld   a,(cursor_color_8802)]
	and.b	#0x1F,d0                         	| mask attribute bits [and  0x1F]
l_294f:
    add.w	#0x400,d6		                  	| address of attributes = screen + 0x400 [ld   de,0x0400]
	jbsr	osd_w_colorram                         	| store attribute for tile [ld   (hl),a]
												| [ld   a,c]
	addq.b	#1,d2                           	| X += 1 [inc  a]
												| [ld   c,a]
	cmp.b	#0x1D,d2                         	| X > 0x1C (end of row) ? [cp   0x1D]
	jcs	l_2966                             	| no, store X and Y and go out [jr   c,0x2966]
	clr.b	d2                               	| set C (X) to 0 [ld   c,0x00]
	addq.b	#1,d1                           	| [inc  a]	                           	| X += 1 [ld   b,a]
	cmp.b	#0x24,d1                         	| Y > 0x24 (end of screen) ? [cp   0x24]
	jcs	l_2966                             		| no, leave it [jr   c,0x2966]
	clr.b	d1                               	| start of line [ld   b,0x00]
l_2966:
	move.b	d2,cursor_x_8800                	| update current cursor pos [ld   (cursor_x_8800),bc]
	move.b	d1,cursor_y_8801                	| update current cursor pos [ld   (cursor_x_8800),bc]
	move.l	(sp)+,a0                        	| [pop  hl]
	movem.w	(sp)+,d0-d3                        	| [pop  de]
	                        	| [pop  bc]
	                        	| [pop  bc]
	                        	| [pop  af]
	rts                                    	| [ret]

* converts coordinates to screen address
* 8000 is bottom of screen
* < B: X (D1)
* < C: Y (D2)
* > HL (D6)
convert_coords_to_screen_address_296F:
	move.b	d1,d0                           	| load B into A [ld   a,b]
	cmp.b	#0x20,d0                         	| is A < 0x20 [cp   0x20]
	jcc	l_2989                             	| if A >= 0x20 goto 0x2989 [jr   nc,0x2989]
	move.b	d2,d0                           	| load C (Y) into A [ld   a,c]
	cmp.b	#0x1C,d0                         	| compare [cp   0x1C]
	jcc	l_29b2                             	| if A >= 0x1C goto 0x29B2 [jr   nc,0x29B2]
	add.b	d0,d0                            	| multiply a by 2 [add  a,a]
	clr.w	d3                               	| [ld   d,0x00]
	move.b	d0,d3                           	| extend a into DE [ld   e,a]
	lea	screen_line_address_table_29B6(pc),a0	| [ld   hl,screen_line_address_table_29B6]
	move.w	(a0,d3.w),d3						| to get an entry into address table
	move.b	(a0),d4                         	| load e [ld   e,(hl)]
	clr		d6                               	| [ld   h,0x00]
	move.b	d1,d6                           	| [ld   l,b]
* acts like multiply table for Y plus X
	add.w	d3,d6							| [add  hl,de]
	rts                                    	| [ret]
* handle limit cases
l_2989:
	cmp.b	#0x22,d0                         	| [cp   0x22]
	jcc	l_2999                             	| [jr   nc,0x2999]
	move.w	#0x8002,d6                      	| [ld   hl,0x8002]
	btst.b	#0,d0                           	| [bit  0,a]
	jeq	l_2997                             	| [jr   z,0x2997]
	move.w	#0x8022,d6                     	| [ld   hl,0x8022]
l_2997:
	jra	l_29a7                             	| [jr   0x29A7]
l_2999:
	cmp.b	#0x24,d0                         	| [cp   0x24]
	jcc	l_29b2                             	| [jr   nc,0x29B2]
	move.w	#0x83C2,d6                      	| set screen address to 83C2 [ld   hl,0x83C2]
	btst.b	#0,d0                           	| [bit  0,a]
	jeq	l_29a7                             	| [jr   z,0x29A7]
	move.w	#0x83E2,d6                      	| set screen address to 83E2 [ld   hl,0x83E2]
l_29a7:
	move.b	#0x1B,d0                        	| [ld   a,0x1B]
	cmp.b	d2,d0                            	| [cp   c]
	jcs	l_29b2                             	| [jr   c,0x29B2]
	sub.b	d2,d0                            	| [sub  c]
	clr		d3                               	| [ld   d,0x00]
	move.b	d0,d3                           	| [ld   e,a]
	add.w	d3,d6								| [add hl,de]
	rts                                    	| [ret]
l_29b2:
	move.w	#0x8000,d6      	| [ld   hl,video_tile_memory_8000]
	rts                                    	| [ret]

screen_line_address_table_29B6:
	.word	0x83a0,0x8380,0x8360,0x8340,0x8320,0x8300,0x82e0,0x82c0
	.word	0x82a0,0x8280,0x8260,0x8240,0x8220,0x8200,0x81e0,0x81c0
	.word	0x81a0,0x8180,0x8160,0x8140,0x8120,0x8100,0x80e0,0x80c0
	.word	0x80a0,0x8080,0x8060,0x8040,0x8020,0x8000,0x8000

* prints a line with a possible delay between each character
* HL (a0) contains pointer on coordinates + color & attributes + text
* and is updated on exit
* if text attribute bit 7 is set, then each character is printed with a delay
* making a typewriter effect
 
print_line_typewriter_style_29F4:
	move.b	(a0)+,d0                         	| load text X [ld   a,(hl)]
	move.b	d0,cursor_x_8800                	| store in current X [ld   (cursor_x_8800),a]
	                           	| [inc  hl]
	move.b	(a0)+,d0                         	| load text Y [ld   a,(hl)]
	move.b	d0,cursor_y_8801                	| store in current Y [ld   (cursor_y_8801),a]
	                           	| [inc  hl]
	move.b	(a0)+,d0                         	| load text color [ld   a,(hl)]
	move.b	d0,cursor_color_8802            	| store in current color [ld   (cursor_color_8802),a]
	                           	| [inc  hl]
l_2a03:
	move.b	(a0),d0                         	| get character [ld   a,(hl)]
	btst.b	#7,d0                           	| [bit  7,a]
	jne	l_2a1a                             	| [jr   nz,0x2A1A]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	cursor_color_8802,d0            	| [ld   a,(cursor_color_8802)]
	btst.b	#7,d0                           	| stop when last bit is set [bit  7,a]
	jeq	l_2a03                             	| [jr   z,0x2A03]
	move.b	#0x04,d0                        	| [ld   a,0x04]
	jbsr	delay_28D1                        	| [call delay_28D1]
	jra	l_2a03                             	| [jr   0x2A03]
l_2a1a:
	and.b	#0x7F,d0                         	| [and  0x7F]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	cursor_color_8802,d0            	| [ld   a,(cursor_color_8802)]
	btst.b	#7,d0                           	| [bit  7,a]
	bne.b	0f
	rts                                    	| [ret  z]
0:
	move.b	#0x04,d0                        	| [ld   a,0x04]
	jbsr	delay_28D1                        	| [call delay_28D1]
	rts                                    	| [ret]
	
l_2a2c:
	lea	push_string_2A7D(pc),a0            	| [ld   hl,push_string_2A7D]
	jbsr	print_line_typewriter_style_29F4                   	| [call print_line_typewriter_style_29F4]
	lea	push_string_2A7D+0x87-0x7D(pc),a0    	| [ld   hl,start_button_string_2A87]
	jbsr	print_line_typewriter_style_29F4                   	| [call print_line_typewriter_style_29F4]
	lea	push_string_2A7D+0x97-0x7D(pc),a4	| [ld   bc,one_or_two_player_string_2A97]
	move.b	#0x01,d3                        	| [ld   d,0x01]
	move.b	number_of_credits_8808,d0       	| [ld   a,(number_of_credits_8808)]
	cmp.b	d3,d0                            	| [cp   d]
	jne	l_2a46                             	| [jr   nz,0x2A46]
	lea	push_string_2A7D+0xA8-0x7D(pc),a4 	| [ld   bc,one_player_only_string_2AA8]
l_2a46:
	move.b	d1,d5                           	| [ld   h,b]
	move.b	d2,d6                           	| [ld   l,c]
	jbsr	print_line_typewriter_style_29F4                   	| [call print_line_typewriter_style_29F4]
	lea	push_string_2A7D+0xB8-0x7D(pc),a0          	| [ld   hl,credit_string_2AB8]
	jbsr	print_line_typewriter_style_29F4                   	| [call print_line_typewriter_style_29F4]
	jbsr	display_number_of_credits_2B7A    	| [call display_number_of_credits_2B7A]
	lea	copyright_string_2ACE(pc),a0       	| [ld   hl,copyright_string_2ACE]
	jbsr	print_line_typewriter_style_29F4                   	| [call print_line_typewriter_style_29F4]
	lea	bonus_for_30000_pts_2ADC(pc),a0    	| [ld   hl,bonus_for_30000_pts_2ADC]
	jbsr	print_line_typewriter_style_29F4                   	| [call print_line_typewriter_style_29F4]
**	lea	for_50000_pts_2AF3(pc),a0          	| [ld   hl,for_50000_pts_2AF3]
**	jbsr	osd_get_dip
**	move.b	dip_switches_9040,d0            	| [ld   a,(dip_switches_9040)]
**	btst.b	#0,d0                           	| [bit  0,a]
* if DSW is set accordignly, overwrite "30000" string with "50000"
**	beq	0f
**	jbsr	print_line_typewriter_style_29F4                   	| [call nz,print_line_typewriter_style_29F4]
*0:
	move.b	#0x0B,d0                        	| [ld   a,0x0B]
	move.b	d0,cursor_color_8802            	| [ld   (cursor_color_8802),a]
											| [ld   h,0x14]
											| [ld   l,0x03]
	move.w	#0x0314,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	move.b	#0x24,d0                        	| [ld   a,0x24]
	jbsr	set_2x2_tile_2F00                 	| [call set_2x2_tile_2F00]
	rts                                    	| [ret]
	
push_string_2A7D:
	.byte	0x0A,0x09,0x17,0x50,0x20,0x55,0x20,0x53,0x20
	.byte	0xC8,0x07,0x0C,0x10,0x53,0x54,0x41  | . .P U S H...STA
	.byte	0x52,0x54,0x20,0x20,0x42,0x55,0x54,0x54,0x4F,0xCE,0x07,0x0F,0x18,0x31,0x20,0x4F   | RT  BUTTON...1 O
	.byte	0x52,0x20,0x32,0x20,0x50,0x4C,0x41,0x59,0x45,0x52,0xD3,0x07,0x0F,0x18,0x31,0x20   | R 2 PLAYERS...1
	.byte	0x50,0x4C,0x41,0x59,0x45,0x52,0x20,0x4F,0x4E,0x4C,0xD9,0x07,0x12,0x10,0x43,0x52   | PLAYER ONLY...CR
	.byte	0x45,0x44,0x49,0x54,0xA0,0x07,0x0F,0x10,0x46,0x52,0x45,0x45,0x20,0x50,0x4C,0x41   | EDITS...FREE PLA
	.byte	0xD9

copyright_string_2ACE:
	.byte	0x08,0x19,0x10,0x40,0x20,0x53,0x45,0x47,0x41,0x20,0x31,0x39,0x38,0xB2
bonus_for_30000_pts_2ADC:
	.byte	0x06,0x15,0x18,0x42,0x4F,0x4E,0x55,0x53,0x20,0x46,0x4F,0x52,0x20,0x33,0x30,0x30,0x30   |..BONUS FOR 3000
	.byte	0x30,0x20,0x50,0x54,0x53,0xBA
for_50000_pts_2AF3:
	.byte	0x10,0x15,0x18,0x35,0x30,0x30,0x30,0xB0  | 0 PTS....50000

	.align	2

update_all_scores_2B10:
	lea	score_titles_string_2B20,a0    	| [ld   hl,score_titles_string_2B20]
	jbsr	print_line_typewriter_style_29F4                   	| [call print_line_typewriter_style_29F4]
	jbsr	write_hiscore_to_screen_2B93      	| [call write_hiscore_to_screen_2B93]
	jbsr	update_and_display_p1_score_2BAE  	| [call update_and_display_p1_score_2BAE]
	jbsr	update_and_display_p2_score_2C24  	| [call update_and_display_p2_score_2C24]
	rts                                    	| [ret]

score_titles_string_2B20:
	dc.b	0x01,0x22,0x11,0x31,0x50,0x20,0x20,0x20,0x20,0x20,0x20,0x20
	dc.b	0x48,0x49,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x32,0xD0   | 01 21 10 43 52 45 44 49 D4        2.!.CREDI
	.align	2

* < HL (d6): write pseudo-BCD 4 digits at current cursor
* updates number_buffer_8803
convert_number_2B40:
	move.l	a2,-(sp)                        	| [push ix]
	move.l	a3,-(sp)                        	| [push iy]
	lea	powers_of_ten_table_2B70(pc),a3    	| [ld   iy,powers_of_ten_table_2B70]
	lea	number_buffer_8803,a2          	| [ld   ix,number_buffer_8803]
l_2b4c:
	clr.b	d0                               	| [xor  a]
	move.w	(a3),d3                    	| [ld   e,(iy+$00)]
												| [ld   d,(iy+$01)]
l_2b53:
											| [and  a]
	sub.w	d3,d6							| [sbc  hl,de] with C cleared, no sub hl,de instruction
	jcs	l_2b5b                             	| [jr   c,$2B5B]
	addq.b	#1,d0                           	| [inc  a]
	jra	l_2b53                             	| [jr   $2B53]
l_2b5b:
	add.w	d3,d6						| [add  hl,de]
	or.b	#0x30,d0                          	| add '0' character [or   $30]
	move.b	d0,(a2)+                    	| store in buffer [ld   (ix+$00),a]
	                           	| [inc  ix]
	addq.w	#2,a3                           	| [inc  iy]*2
	btst.b	#0,d3                           	| [bit  0,e]
	jeq	l_2b4c                             	| [jr   z,$2B4C]
	move.l	(sp)+,a3                        	| [pop  iy]
	move.l	(sp)+,a2                        	| [pop  ix]
	rts                                    	| [ret]
powers_of_ten_table_2B70:
	.word	10000,1000,100,10,1


display_number_of_credits_2B7A:
	clr		d6                               	| [ld   h,$00]
	move.b	number_of_credits_8808,d6       	| [ld   a,(number_of_credits_8808)]
												| [ld   l,a]
	jbsr	convert_number_2B40               	| [call convert_number_2B40]
												| [ld   h,$12]
												| [ld   l,$0F]
	move.w	#0x0F12,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	move.b	#0x10,d0                        	| [ld   a,$10]
	move.b	d0,cursor_color_8802            	| [ld   (cursor_color_8802),a]
	jbsr	write_2_digits_to_screen_2C6F     	| [call write_2_digits_to_screen_2C6F]
	rts        


write_hiscore_to_screen_2B93:
	move.w	high_score_880C,d6          	| [ld   hl,(high_score_880C)]
	jbsr	convert_number_2B40               	| [call convert_number_2B40]
												| [ld   h,$22]
												| [ld   l,$0C]
	* Y=$22: top of screen!!
	move.w	#0x0C22,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	move.b	#0x10,d0                        	| [ld   a,$10]
	move.b	d0,cursor_color_8802            	| [ld   (cursor_color_8802),a]
	jbsr	write_5_digits_to_screen_2C54     	| [call write_5_digits_to_screen_2C54]
	move.b	#0x30,d0                        	| write the fixed '0' for score [ld   a,$30]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	rts                                    	| [ret]

update_and_display_p1_score_2BAE:
	move.w	player_1_score_880E,d6      	| [ld   hl,(player_1_score_880E)]
	jbsr	convert_number_2B40               	| [call convert_number_2B40]
												| [ld   h,$22]
												| [ld   l,$03]
	move.w	#0x0322,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	move.b	#0x10,d0                        	| [ld   a,$10]
	move.b	d0,cursor_color_8802            	| [ld   (cursor_color_8802),a]
	jbsr	write_5_digits_to_screen_2C54     	| [call write_5_digits_to_screen_2C54]
	move.b	#0x30,d0                        	| write the fixed '0' for score [ld   a,$30]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	jbsr	check_p1_score_for_extra_life_2BAE	| [call check_p1_score_for_extra_life_2BAE]
	move.w	high_score_880C,d6    		      	| [ld   hl,(high_score_880C)]
	move.w	player_1_score_880E,d3    		  	| [ld   de,(player_1_score_880E)]
	jbsr	compare_hl_to_de_2D99             	| [call compare_hl_to_de_2D99]
	bcs.b	0f
	rts                                    	| [ret  nc]
0:
	move.w	d3,high_score_880C              	| [ld   (high_score_880C),de]
	jbsr	write_hiscore_to_screen_2B93      	| [call write_hiscore_to_screen_2B93]
	rts                                    	| [ret]

check_p1_score_for_extra_life_2BAE:
	lea	lives_counter_p1_8814,a0       	| [ld   hl,lives_counter_p1_8814]
	btst.b	#7,(a0)                         	| [bit  7,(hl)]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	move.w	d6,-(sp)                        	| [push hl]
	move.w	player_1_score_880E,d6      	| [ld   hl,(player_1_score_880E)]
	move.w	#0x0BB8,d3                      	| [ld   de,$0BB8]
*	move.b	dip_switches_9040,d0            	| [ld   a,(dip_switches_9040)]
*	btst.b	#0,d0                           	| [bit  0,a]
*	jeq	l_2bf5                             	| [jr   z,$2BF5]
*	move.w	#0x1388,d3                      	| 5000 [ld   de,$1388]
*l_2bf5:
	jbsr	compare_hl_to_de_2D99             	| [call compare_hl_to_de_2D99]
	movem.w	(sp)+,d6                        	| [pop  hl]
	bcc.b	0f
	rts                                    	| [ret  c]
0:
l_2bfa:
	addq.b	#1,(a0)                         	| [inc  (hl)]
	bset.b	#7,(a0)                         	| [set  7,(hl)]
	jbsr	draw_lives_2D13                            	| [call $2D13]
	move.b	#0x01,d1                        	| [ld   b,$01]
	* sound stuff jbsr	l_18af                            	| [call $18AF]
	rts                                    	| [ret]

check_p2_score_for_extra_life_2C06:
	lea	lives_counter_p2_8815,a0 		      	| [ld   hl,lives_counter_p2_8815]
	btst.b	#7,(a0)                         	| [bit  7,(hl)]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	move.w	d6,-(sp)                        	| [push hl]
	move.w	player_2_score_8810,d6      	| [ld   hl,(player_2_score_8810)]
	move.w	#0x0BB8,d3                      	| [ld   de,$0BB8]
*	move.b	dip_switches_9040,d0            	| [ld   a,(dip_switches_9040)]
*	btst.b	#0,d0                           	| [bit  0,a]
*	jeq	l_2c1d                             	| [jr   z,$2C1D]
*	move.w	#0x1388,d3                      	| 5000 [ld   de,$1388]
*l_2c1d:
	jbsr	compare_hl_to_de_2D99             	| [call compare_hl_to_de_2D99]
	movem.w	(sp)+,d6                        	| [pop  hl]
	bcc.b	0f
	rts                                    	| [ret  c]
0:
	jra	l_2bfa                             	| [jr   $2BFA]

update_and_display_p2_score_2C24:
	move.w	player_2_score_8810,d6      	| [ld   hl,(player_2_score_8810)]
	jbsr	convert_number_2B40               	| [call convert_number_2B40]
											| [ld   h,$22]
											| [ld   l,$15]
	move.w	#0x1522,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	move.b	#0x10,d0                        	| [ld   a,$10]
	move.b	d0,cursor_color_8802            	| [ld   (cursor_color_8802),a]
	jbsr	write_5_digits_to_screen_2C54     	| [call write_5_digits_to_screen_2C54]
	move.b	#0x30,d0                        	| [ld   a,$30]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	jbsr	check_p2_score_for_extra_life_2C06	| [call check_p2_score_for_extra_life_2C06]
	move.w	high_score_880C,d6          	| [ld   hl,(high_score_880C)]
	move.w	player_2_score_8810,d3      	| [ld   de,(player_2_score_8810)]
	jbsr	compare_hl_to_de_2D99             	| [call compare_hl_to_de_2D99]
	bcs.b	0f
	rts                                    	| [ret  nc]
0:
	move.w	d3,high_score_880C              	| [ld   (high_score_880C),de]
	jbsr	write_hiscore_to_screen_2B93      	| [call write_hiscore_to_screen_2B93]
	rts                                    	| [ret]

write_5_digits_to_screen_2C54:
	move.b	#0x05,d1                        	| write 5 numbers [ld   b,$05]
	lea	number_buffer_8803,a0          	| source [ld   hl,number_buffer_8803]
l_2c59:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	cmp.b	#0x30,d0                         	| compare to '0' [cp   $30]
	jne	l_2c67                             	| different from 0, write all numbers [jr   nz,$2C67]
* do not write leading zeroes
	move.b	#0x20,d0                        	| [ld   a,$20]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_2c59                             	| [djnz $2C59]
	rts                                    	| [ret]
l_2c67:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	addq.w	#1,a0                           	| [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_2c67                             	| [djnz $2C67]
	rts                                    	| [ret]

write_2_digits_to_screen_2C6F:
	move.b	#0x02,d1                        	| write 2 numbers [ld   b,$02]
	lea	number_buffer_8803+3,a0        	| source [ld   hl,number_buffer_8803+3]
	jra	l_2c59      

draw_lives_2D0C:
	jbsr	get_nb_lives_289E                 	| [call get_nb_lives_289E]
	tst.b	d0                               	| [and  a]
	bne.b	0f
	rts                                    	| [ret  z]
0:
	jra	l_2d18                             	| [jr   $2D18]
draw_lives_2D13:
	jbsr	get_nb_lives_289E                 	| [call get_nb_lives_289E]
	subq.b	#1,d0                           	| [dec  a]
	bne.b	0f
	rts                                    	| [ret  z]
0:
l_2d18:
	cmp.b	#0x05,d0                         	| [cp   $05]
	jcs	l_2d1e                             	| [jr   c,$2D1E]
	move.b	#0x04,d0                        	| [ld   a,$04]
l_2d1e:
	move.b	d0,d1                           	| [ld   b,a]
	move.b	#0x0B,d0                        	| [ld   a,$0B]
	move.b	d0,cursor_color_8802            	| [ld   (cursor_color_8802),a]
	move.b	#0x24,d2                        	| pengo life upper left tile [ld   c,$24]
l_2d26:
	move.w	d1,-(sp)                        	| [push bc]
	move.b	d1,d0                           	| [ld   a,b]
	subq.b	#1,d0                           	| [dec  a]
	add.b	d0,d0                            	| [add  a,a]
												| [ld   h,$23]
	move.w	#0x23,d5											| [ld   l,a]
	move.w	d5,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	move.w	d5,-(sp)                        	| [push hl]
	move.b	d2,d0                           	| [ld   a,c]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	addq.b	#1,d0                           	| [inc  a]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	move.w	(sp)+,d5                        	| [pop  hl]
	clr.b	d5                               	| [ld   h,$00]
	move.b	d5,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	move.w	d5,d6
	lsr.w	#8,d6
	move.b	d5,cursor_y_8801                	| [ld   (cursor_x_8800),hl]
	addq.b	#1,d0                           	| [inc  a]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	addq.b	#1,d0                           	| [inc  a]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	move.w	(sp)+,d1                        	| [pop  bc]
	subq.b	#1,d1                           	| [...]
	jne	l_2d26                             	| [djnz $2D26]
	rts                                    	| [ret]

* kinds of jmp (de,a*2) (68k instruction)
* < de / A1:	jump table
* < a / D0.B:	index
indirect_jump_2D8F:
	and.w	#0xFF,d0
	add.w	d0,d0
	add.w	d0,d0
	move.l	(a1,d0.w),a0
	jmp		(a0)                               	| [jp   (hl)]


* computes D-H, then E-L if D-H != 0
* < HL (d6)
* < DE (d3)
* < Z if equal, NZ otherwise, C flag set for first different value
compare_hl_to_de_2D99:
	cmp.w	d3,d6
	rts                                    	| [ret]

draw_borders_2E5D:
	move.b	currently_playing_8819,d0       	| [ld   a,(currently_playing_8819)]
	tst.b	d0                               	| [and  a]
	jeq	l_2e6a                             	| [jr   z,$2E6A]
	clr.b	d0                               	| [ld   a,$00]
	move.b	d0,cursor_color_8802            	| [ld   (cursor_color_8802),a]
	jra	l_2e6f                             	| [jr   $2E6F]

l_2e6a:
	move.b	#0x09,d0                        	| [ld   a,$09]
	move.b	d0,cursor_color_8802            	| [ld   (cursor_color_8802),a]
l_2e6f:
	move.b	#0x10,d4                        	| [ld   e,$10]
	jbsr	draw_vertical_walls_2E81          	| [call draw_vertical_walls_2E81]
	move.b	#0x11,d4                        	| [ld   e,$11]
	jbsr	draw_horizontal_walls_2E92        	| [call draw_horizontal_walls_2E92]
	rts                                    	| [ret]
* used to replace walls by stars when diamonds are aligned
draw_borders_2E7A:
	jbsr	draw_vertical_walls_2E81          	| [call draw_vertical_walls_2E81]
	jbsr	draw_horizontal_walls_2E92        	| [call draw_horizontal_walls_2E92]
	rts                                    	| [ret]

draw_vertical_walls_2E81:
	move.b	#0x0,d1                      	| [ld   bc,$0100]
	move.b	#0x1,d2                      	| [ld   bc,$0100]
	move.b	#0x1C,d3                        	| [ld   d,$1C]
	jbsr	write_character_and_code_at_xy_2EA3	| [call write_character_and_code_at_xy_2EA3]
	move.b	#0x0,d1                      	| [ld   bc,$2000]
	move.b	#0x20,d2                      	| [ld   bc,$2000]
	move.b	#0x1C,d3                        	| [ld   d,$1C]
	jbsr	write_character_and_code_at_xy_2EA3	| [call write_character_and_code_at_xy_2EA3]
	rts                                    	| [ret]

* BC: X,Y
* D: number of repeats
* E: character to set (with current cursor color)
fill_line_with_character_current_color_2EB8:
	move.w	d3,-(sp)                        	| [push de]
	jbsr	convert_coords_to_screen_address_296F	| [call convert_coords_to_screen_address_296F]
	move.w	(sp)+,d3                        	| [pop  de]
	move.b	d4,d0
	bsr		osd_w_videoram					| [ld   (hl),e]
												| [push de]
											| [ld   de,$0400]
	add.w	#0x400,d6						| add  hl,de
	move.b	cursor_color_8802,d0            	| [ld   a,(cursor_color_8802)]
	bsr		osd_w_colorram                         	| [ld   (hl),a]
										| [pop  de]
	addq.b	#1,d1                           	| [inc  b]
	subq.b	#1,d3                           	| [dec  d]
	jne	fill_line_with_character_current_color_2EB8	| [jr   nz,fill_line_with_character_current_color_2EB8]
	rts                                    	| [ret]


draw_horizontal_walls_2E92:
	move.b	#0x0,d1                      	| [ld   bc,$0100]
	move.b	#0x1,d2                      	| [ld   bc,$0100]
	move.b	#0x20,d3                        	| [ld   d,$20]
	jbsr	fill_line_with_character_current_color_2EB8	| [call fill_line_with_character_current_color_2EB8]
	move.b	#0x1B,d2                      	| [ld   bc,$2000]
	move.b	#0x01,d3                        	| [ld   d,$1C]
	move.b	#0x20,d3                        	| [ld   d,$20]
	jbsr	fill_line_with_character_current_color_2EB8	| [call fill_line_with_character_current_color_2EB8]
	rts                                    	| [ret]

* < A: code
* < B: X
* < C: Y
* < E: character

write_character_and_code_at_xy_2EA3:
	move.w	d3,-(sp)                        	| [push de]
	jbsr	convert_coords_to_screen_address_296F	| [call convert_coords_to_screen_address_296F]
	move.w	(sp)+,d3                        	| [pop  de]
	move.b	d4,d0                         	| [ld   (hl),e]
	jbsr	osd_w_videoram
												| [ld   de,$0400]
	add.w	#0x400,d6							| [add  hl,de]
	move.b	cursor_color_8802,d0            	| [ld   a,(cursor_color_8802)]
	jbsr	osd_w_colorram                         	| [ld   (hl),a]
												| [pop  de]
	addq.b	#1,d2                           	| [inc  c]
	subq.b	#1,d3                           	| [dec  d]
	jne	write_character_and_code_at_xy_2EA3	| [jr   nz,write_character_and_code_at_xy_2EA3]
	rts                                    	| [ret]
	
draw_ice_block_tile_2EFE:
	move.b	#0x18,d0                        	| [ld   a,$18]
* writes 2x2 4 characters, using consecutive tile codes
* < A: start tile code
set_2x2_tile_2F00:
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	addq.b	#1,d0                           	| [inc  a]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	addq.b	#1,d0                           	| [inc  a]
	jbsr	move_cursor_2_291E        	| [call move_cursor_2_291E]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	addq.b	#1,d0                           	| [inc  a]
	jbsr	set_tile_at_current_pos_293C      	| [call set_tile_at_current_pos_293C]
	addq.b	#1,d0                           	| [inc  a]
	rts                                    	| [ret]


* < BC: X,Y where to draw diamond
set_diamond_position_2FA9:
	move.b	d2,cursor_x_8800                	| [ld   (cursor_x_8800),bc]
	move.b	d1,cursor_y_8801                	| [ld   (cursor_x_8800),bc]
	move.b	#0x1C,d0                        	| [ld   a,$1C]
	jra	set_2x2_tile_2F00                  	| [jp   set_2x2_tile_2F00]
	
* < A: sprite number to display
* < HL: points on X,Y
display_sprite_3154:
	lea	sprite_ram_9020(pc),a3             	| [ld   iy,sprite_ram_9020]
	add.b	d0,d0                            	| [add  a,a]
	clr.b	d3                               	| [ld   d,$00]
	move.b	d0,d3                           	| [ld   e,a]
	add.w	d3,a3								| [add  iy,de]

	move.b	(a0),d0                         	| [ld   a,(hl)]
	not.b	d0                               	| [cpl]
l_316a:
	move.b	d0,(0x00,a3)                    	| [ld   (iy+$00),a]
	addq.w	#1,a0                           	| [inc  hl]

	move.b	(a0),d0                         	| [ld   a,(hl)]
	not.b	d0                               	| 255-Y [cpl]
	addq.b	#1,d0                           	| [inc  a]
l_317b:
	move.b	d0,(0x01,a3)                    	| [ld   (iy+$01),a]
	rts                                    	| [ret]

* < HL: pengo/snobee struct 8Dxx
* < A: pengo sprite index
display_character_sprite_318A:
	lea	sprite_ram_8FF2-2,a3          	| [ld   iy,stack_pointer_8FF0]
	addq.w	#2,a0                           	| [inc  hl]
											  | skip coordinates [inc  hl]
	add.b	d0,d0                            	| we only read sprite index & color [add  a,a]
	clr.b	d3                               	| [ld   d,$00]
	move.b	d0,d3                           	| [ld   e,a]
	add.w	d3,a3								| [add  iy,de]
	move.b	(a0),d3                         	| [ld   d,(hl)]

	move.b	d3,(0x00,a3)                    	| [ld   (iy+$00),d]
	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(0x01,a3)                    	| [ld   (iy+$01),a]
	rts                                    	| [ret]
	
clear_sprites_31B7:
	lea	sprite_ram_9020,a0             	| [ld   hl,sprite_ram_9020]
	move.b	#0x10,d1                        	| [ld   b,$10]
l_31bc:
	clr.b	(a0)+                             	| [ld   (hl),$00]
	subq.b	#1,d1                           	| [...]
	jne	l_31bc                             	| [djnz $31BC]
	rts                                    	| [ret]

l_32bc:
	move.b	game_playing_8817,d0            	| [ld   a,(game_playing_8817)]
	tst.b	d0                               	| [and  a]
	bne.b	0f
	rts                                    	| [ret  z]
0:
	move.b	timer_16bit_8822,d0             	| [ld   a,(timer_16bit_8822)]
	and.b	#0x1F,d0                         	| [and  0x1F]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	move.b	#0x01,d1                      	| [ld   bc,0x2201]
	move.b	#0x22,d2                      	| [ld   bc,0x2201]
	move.b	player_number_8816,d0           	| [ld   a,(player_number_8816)]
	btst.b	#0,d0                           	| [bit  0,a]
	jeq	l_32d4                             	| [jr   z,0x32D4]
	move.b	#0x13,d1                      	| [ld   bc,0x2213]
	move.b	#0x22,d2                      	| [ld   bc,0x2213]
l_32d4:
	move.b	timer_16bit_8822,d0             	| [ld   a,(timer_16bit_8822)]
	btst.b	#5,d0                           	| [bit  5,a]
	jeq	l_32ea                             	| [jr   z,0x32EA]
	jbsr	convert_coords_to_screen_attributes_address_4BDC	| [call convert_coords_to_screen_attributes_address_4BDC]
	moveq	#0x11,d0                             | [ld   (hl),0x11]
	jbsr	osd_w_colorram                      	
	addq.b	#1,d2                           	| [inc  c]
	jbsr	convert_coords_to_screen_attributes_address_4BDC	| [call convert_coords_to_screen_attributes_address_4BDC]
	moveq	#0x11,d0                             | [ld   (hl),0x11]
	jbsr	osd_w_colorram                      	
	jbsr	l_32f9                            	| [call 0x32F9]
	rts                                    	| [ret]
l_32ea:
	jbsr	convert_coords_to_screen_attributes_address_4BDC	| [call convert_coords_to_screen_attributes_address_4BDC]
	moveq	#0,d0                             	| [ld   (hl),0x00]
	jbsr	osd_w_colorram
	addq.b	#1,d2                           	| [inc  c]
	jbsr	convert_coords_to_screen_attributes_address_4BDC	| [call convert_coords_to_screen_attributes_address_4BDC]
	moveq	#0,d0                             	| [ld   (hl),0x00]
	jbsr	osd_w_colorram
	jbsr	l_32fd                            	| [call 0x32FD]
	rts                                    	| [ret]
l_32f9:
	move.b	#0x10,d0                        	| [ld   a,0x10]
	jra	l_32ff                             	| [jr   0x32FF]
l_32fd:
	move.b	#0x0C,d0                        	| [ld   a,0x0C]
l_32ff:
	                       	| [ld   l,0x08]+[ld  h,0]
	move.w	#0x0800,cursor_x_8800                	| [ld   (cursor_x_8800),hl]
	move.b	#0x0C,d1                        	| [ld   b,0x0C]
l_3308:
	jbsr	set_attribute_at_current_pos_292D 	| [call set_attribute_at_current_pos_292D]
	subq.b	#1,d1                           	| [...]
	jne	l_3308                             	| [djnz 0x3308]
	rts       	

display_snobee_sprite_33CE:
	move.b	(char_id,a2),d0                 	| load sprite index [ld   a,(ix+char_id)]
	move.l	a2,a0                        	| [push ix]
											| [pop  hl]
	jbsr	display_sprite_3154               	| [call display_sprite_3154]
	rts
	
animate_pengo_39A4:
	move.b	(0x08,a2),d0                    	| [ld   a,(ix+$08)]
	tst.b	d0                               	| [and  a]
	bne.b	0f
	rts                                    	| returns if a == 0 [ret  z]
0:
	move.b	counter_lsb_8824,d0             	| [ld   a,(counter_lsb_8824)]
	and.b	#0x1F,d0                         	| [and  $1F]
	beq.b	0f
	rts                                    	| returns if counter_lsb_8824 isn't dividable by 32? [ret  nz]
0:
 * counter 1 out of 32 pengo animation moves
	jra	l_396b                             	| [jr   $396B]

l_3957:
	move.b	(0x08,a2),d0                    	| [ld   a,(ix+$08)]
	tst.b	d0                               	| [and  a]
	bne.b	0f
	rts                                    	| [ret  z]
0:
	move.b	counter_lsb_8824,d0             	| [ld   a,(counter_lsb_8824)]
	and.b	#0x1F,d0                         	| [and  $1F]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
 * counter 1 out of 32 snobees animation moves
	addq.b	#1,(0x0c,a2)                    	| [inc  (ix+$0c)]
	move.b	(0x0c,a2),d0                    	| [ld   a,(ix+$0c)]
	and.b	#0x03,d0                         	| [and  $03]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
l_396b:
	clr.b	d1                               	| [ld   b,$00]
	move.b	(char_id,a2),d0                 	| [ld   a,(ix+char_id)]
	cmp.b	#0x05,d0                         	| [cp   $05]
	jeq	l_3985                             	| [jr   z,$3985]
	move.b	#0x26,d1                        	| [ld   b,$26]
	move.b	(ai_mode,a2),d0                 	| [ld   a,(ix+ai_mode)]
	cmp.b	#0x02,d0                         	| [cp   $02]
	jeq	l_3985                             	| [jr   z,$3985]
	move.b	#0x2C,d1                        	| [ld   b,$2C]
	cmp.b	#0x09,d0                         	| [cp   $09]
	jcc	l_3985                             	| [jr   nc,$3985]
	move.b	#0x12,d1                        	| [ld   b,$12]
l_3985:
	addq.b	#1,(0x0c,a2)                    	| [inc  (ix+$0c)]
	move.b	(facing_direction,a2),d0        	| [ld   a,(ix+facing_direction)]
	cmp.b	#0x03,d0                         	| [cp   $03]
	jne	l_3990                             	| [jr   nz,$3990]
	subq.b	#1,d0                           	| [dec  a]
l_3990:
	add.b	d0,d0                            	| [add  a,a]
	btst.b	#2,(0x0c,a2)                    	| [bit  2,(ix+$0c)]
	jne	l_3998                             	| [jr   nz,$3998]
	addq.b	#1,d0                           	| [inc  a]
l_3998:
	add.b	d1,d0                            	| [add  a,b]
	asl.b	#2,d0                            	| [sla  a]
												| [sla  a]
	move.b	d0,(animation_frame,a2)         	| [ld   (ix+animation_frame),a]
	move.b	(facing_direction,a2),d0        	| [ld   a,(ix+facing_direction)]
	cmp.b	#0x03,d0                         	| [cp   $03]
	jne	display_character_sprite_39AB      	| [jr   nz,display_character_sprite_39AB]
	bset.b	#1,(animation_frame,a2)         	| [set  1,(ix+animation_frame)]
display_character_sprite_39AB:
	move.b	(char_id,a2),d0                 	| [ld   a,(ix+char_id)]
	move.l	a2,-(sp)                        	| [push ix]
	move.l	(sp)+,a0                        	| [pop  hl]
	jbsr	display_character_sprite_318A     	| [call display_character_sprite_318A]
	rts                                    	| [ret]
	
	
move_character_according_to_direction_3DD7:
	pea	l_3de4(pc)                      	| [ld   hl,$3DE4]
											| [push hl]
	move.b	(facing_direction,a2),d0        	| [ld   a,(ix+facing_direction)]
	lea	jump_table_3DEE(pc),a1             	| [ld   de,jump_table_3DEE]
	jra	indirect_jump_2D8F                 	| [jp   indirect_jump_2D8F]

l_3de4:
	move.b	(char_id,a2),d0                 	| [ld   a,(ix+char_id)]
	move.l	a2,a0                        	| [push ix]
											| [pop  hl]
	jbsr	display_sprite_3154               	| [call display_sprite_3154]
	rts                                    	| [ret]

jump_table_3DEE:
	.long	pengo_goes_up_3DF6
	.long	pengo_goes_down_3DFA
	.long	pengo_goes_left_3DFE
	.long	pengo_goes_right_3E02

 * movement table
 * pengo go up
pengo_goes_up_3DF6:
	subq.b	#1,(y_pos,a2)                   	| [dec  (ix+y_pos)]
	rts                                    	| [ret]
* pengo goes down
pengo_goes_down_3DFA:
	addq.b	#1,(y_pos,a2)                   	| [inc  (ix+y_pos)]
	rts                                    	| [ret]
* pengo goes left
pengo_goes_left_3DFE:
	subq.b	#1,(x_pos,a2)                   	| [dec  (ix+x_pos)]
	rts                                    	| [ret]
 * pengo goes right
pengo_goes_right_3E02:
	addq.b	#1,(x_pos,a2)                   	| [inc  (ix+x_pos)]
	rts                                    	| [ret]

	
l_3ffa:
	clr.b	d1                               	| [ld   b,$00]
l_3ffc:
	move.b	(facing_direction,a2),d0        	| [ld   a,(ix+facing_direction)]
	cmp.b	#0x03,d0                         	| [cp   $03]
	jne	l_4004                             	| [jr   nz,$4004]
	subq.b	#1,d0                           	| [dec  a]
l_4004:
	add.b	d0,d0                            	| [add  a,a]
	addq.b	#0x06,d0                        	| [add  a,$06]
	add.b	d1,d0                            	| [add  a,b]
	rol.b	#2,d0                            	| [rlca]
											| [rlca]
	move.b	d0,(animation_frame,a2)         	| [ld   (ix+animation_frame),a]
	move.b	(facing_direction,a2),d0        	| [ld   a,(ix+facing_direction)]
	cmp.b	#0x03,d0                         	| [cp   $03]
	jne	l_4018                             	| [jr   nz,$4018]
	bset.b	#1,(animation_frame,a2)         	| [set  1,(ix+animation_frame)]
l_4018:
	jbsr	display_character_sprite_39AB     	| [call display_character_sprite_39AB]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]

l_401f:
	move.b	#0x01,d1                        	| [ld   b,$01]
	jra	l_3ffc                             	| [jr   $3FFC]
l_4023:
	btst.b	#0,(0x09,a2)                    	| [bit  0,(ix+$09)]
	bne	0f
	jbsr	l_402e                            	| [call z,$402E]
0:
	jbsr	l_4037                            	| [call $4037]
	rts                                    	| [ret]

l_402e:
	move.b	#0x01,(stunned_push_block_counter,a2)	| [ld   (ix+stunned_push_block_counter),$01]
	move.b	#0x0F,(0x09,a2)                 	| [ld   (ix+$09),$0F]
	rts                                    	| [ret]
l_4037:
	move.b	counter_lsb_8824,d0             	| count mask [ld   a,(counter_lsb_8824)]
	tst.b	d0                               	| [and  a]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	move.b	(stunned_push_block_counter,a2),d0	| [ld   a,(ix+stunned_push_block_counter)]
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_4046                             	| [jr   z,$4046]
	move.b	d0,(stunned_push_block_counter,a2)	| [ld   (ix+stunned_push_block_counter),a]
	rts                                    	| [ret]
l_4046:
	clr.b	(0x09,a2)                        	| [ld   (ix+$09),$00]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]
l_404e:
	move.b	#0x02,(char_state,a2)           	| [ld   (ix+char_state),$02]
	rts                                    	| [ret]
l_4053:
	move.b	(intermission_dance_counter,a2),d0	| [ld   a,(ix+intermission_dance_counter)]
	lea	table_405C(pc),a1                  	| [ld   de,table_405C]
	jra	indirect_jump_2D8F                 	| [jp   indirect_jump_2D8F]
table_405C:
	.long	l_3ffa
	.long	l_406e
	.long	l_401f
	.long	l_406e
	.long	l_3ffa
	.long	l_406e
	.long	l_401f
	.long	l_406e
	.long	l_404e


l_406e:
	btst.b	#0,(0x09,a2)                    	| [bit  0,(ix+$09)]
	bne	0f
	jbsr	l_4079                            	| [call z,$4079]
0:
	jbsr	l_4082                            	| [call $4082]
	rts                                    	| [ret]
l_4079:
	move.b	#0x02,(stunned_push_block_counter,a2)	| [ld   (ix+stunned_push_block_counter),$02]
	move.b	#0x0F,(0x09,a2)                 	| [ld   (ix+$09),$0F]
	rts                                    	| [ret]
l_4082:
	move.b	counter_lsb_8824,d0             	| [ld   a,(counter_lsb_8824)]
	and.b	#0x1F,d0                         	| [and  $1F]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
 * counter 1 out of 32 pengo breaks block facing left (also in "push start" screen)
	move.b	(stunned_push_block_counter,a2),d0	| [ld   a,(ix+stunned_push_block_counter)]
	subq.b	#1,d0                           	| [dec  a]
	jeq	l_4092                             	| [jr   z,$4092]
	move.b	d0,(stunned_push_block_counter,a2)	| [ld   (ix+stunned_push_block_counter),a]
	rts                                    	| [ret]
l_4092:
	clr.b	(0x09,a2)                        	| [ld   (ix+$09),$00]
	addq.b	#1,(intermission_dance_counter,a2)	| [inc  (ix+intermission_dance_counter)]
	rts                                    	| [ret]
l_409a:
	move.b	(intermission_dance_counter,a2),d0	| [ld   a,(ix+intermission_dance_counter)]
	lea	jump_table_40A3(pc),a1             	| [ld   de,jump_table_40A3]
	jra	indirect_jump_2D8F                 	| [jp   indirect_jump_2D8F]

jump_table_40A3:
	.long	l_40b5
	.long	l_406e
	.long	l_40bc
	.long	l_406e
	.long	l_40b5
	.long	l_406e
	.long	l_40bc
	.long	l_406e
	.long	l_40c6


l_40b5:
	jbsr	l_40d2                            	| [call $40D2]
	jbsr	l_3ffa                            	| [call $3FFA]
	rts                                    	| [ret]

l_40bc:
	jbsr	l_40ce                            	| [call $40CE]
	jbsr	l_401f                            	| [call $401F]
	jbsr	pengo_is_moving_a_wall_4167       	| [call pengo_is_moving_a_wall_4167]
	rts                                    	| [ret]

l_40c6:
	jbsr	l_2e6a                            	| [call $2E6A]
	move.b	#0x02,(char_state,a2)           	| [ld   (ix+char_state),$02]
	rts                                    	| [ret]

l_40ce:
	move.b	#0x01,d1                        	| [ld   b,$01]
	jra	l_40d4                             	| [jr   $40D4]
l_40d2:
	clr.b	d1                               	| [ld   b,$00]
l_40d4:
	move.b	(facing_direction,a2),d0        	| [ld   a,(ix+facing_direction)]
	add.b	d0,d0                            	| [add  a,a]
	add.b	d1,d0                            	| [add  a,b]
	rol.b	#3,d0                            	| [rlca]
											| [rlca]
											| [rlca]
	clr.w	d3                               	| [ld   d,$00]
	move.b	d0,d3                           	| [ld   e,a]
	lea	table_4127(pc),a0                  	| [ld   hl,table_4127]
	add.w	d3,a0							| [add  hl,de]
	move.b	(a0)+,d2                         	| [ld   c,(hl)]
	                           	| [inc  hl]
	move.b	(a0)+,d1                         	| [ld   b,(hl)]
	                           	| [inc  hl]
	move.b	(a0)+,d3                         	| [ld   d,(hl)]
	                           	| [inc  hl]
	move.b	(a0)+,d4                         	| [ld   e,(hl)]
	                           	| [inc  hl]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(0x10,a2)                    	| [ld   (ix+$10),a]
l_40ef:
	move.l	d3,-(sp)                        	| [push de]
	jbsr	convert_coords_to_screen_address_296F	| [call convert_coords_to_screen_address_296F]
	move.l	(sp),d3                        	| [pop  de]
											| [push de]
	btst.b	#2,(0x10,a2)                    	| [bit  2,(ix+$10)]
	jeq	l_40fc                             	| [jr   z,$40FC]
	addq.b	#1,d4                           	| [inc  e]
l_40fc:
	move.b	d4,(a0)                         	| [ld   (hl),e]
	move.l	(sp)+,d3                        	| [pop  de]
	jbsr	l_4118                            	| [call $4118]
	move.l	d3,-(sp)                        	| [push de]
	jbsr	convert_coords_to_screen_address_296F	| [call convert_coords_to_screen_address_296F]
	move.l	(sp),d3                        	| [pop  de]
	                        	| [push de]
	btst.b	#2,(0x10,a2)                    	| [bit  2,(ix+$10)]
	jne	l_410e                             	| [jr   nz,$410E]
	addq.b	#1,d4                           	| [inc  e]
l_410e:
	move.b	d4,(a0)                         	| [ld   (hl),e]
	move.l	(sp)+,d3                        	| [pop  de]
	jbsr	l_4118                            	| [call $4118]
	subq.b	#1,d3                           	| [dec  d]
	subq.b	#1,d3                           	| [dec  d]
	jne	l_40ef                             	| [jr   nz,$40EF]
	rts                                    	| [ret]

l_4118:
	btst.b	#0,(0x10,a2)                    	| [bit  0,(ix+$10)]
	jeq	l_411f                             	| [jr   z,$411F]
	addq.b	#1,d2                           	| [inc  c]
l_411f:
	btst.b	#1,(0x10,a2)                    	| [bit  1,(ix+$10)]
	jeq	l_4126                             	| [jr   z,$4126]
	addq.b	#1,d1                           	| [inc  b]
l_4126:
	rts                                    	| [ret]

table_4127:
	.byte	0x00,0x01,0x1C,0x14,0x01,0x00,0x00,0x00,0x00,0x01,0x1C,0x14,0x05,0x00,0x00,0x00
	.byte	0x00,0x20,0x1C,0x14,0x01,0x00,0x00,0x00,0x00,0x20,0x1C,0x14,0x05,0x00,0x00,0x00
	.byte	0x00,0x01,0x20,0x12,0x02,0x00,0x00,0x00,0x00,0x01,0x20,0x12,0x06,0x00,0x00,0x00
	.byte	0x1B,0x01,0x20,0x12,0x02,0x00,0x00,0x00,0x1B,0x01,0x20,0x12,0x06,0x00,0x00,0x00
	.align	2
	
 * perform those tests only when pengo moves the edge
pengo_is_moving_a_wall_4167:
	lea	snobee_1_struct_8D00,a2        	| [ld   ix,snobee_1_struct_8D00]
	jbsr	snobee_on_waving_edge_4184        	| [call snobee_on_waving_edge_4184]
	lea	snobee_2_struct_8D20,a2        	| [ld   ix,snobee_2_struct_8D20]
	jbsr	snobee_on_waving_edge_4184        	| [call snobee_on_waving_edge_4184]
	lea	snobee_3_struct_8D40,a2        	| [ld   ix,snobee_3_struct_8D40]
	jbsr	snobee_on_waving_edge_4184        	| [call snobee_on_waving_edge_4184]
	lea	snobee_4_struct_8D60,a2        	| [ld   ix,snobee_4_struct_8D60]
	jbsr	snobee_on_waving_edge_4184        	| [call snobee_on_waving_edge_4184]
	rts                                    	| [ret]

snobee_on_waving_edge_4184:
	move.b	(x_pos,a2),d2                   	| [ld   c,(ix+x_pos)]
	move.b	(y_pos,a2),d1                   	| [ld   b,(ix+y_pos)]
	move.b	(char_state,a2),d0              	| [ld   a,(ix+char_state)]
	tst.b	d0                               	| [and  a]
	jne		0f
	rts                                    	| [ret  z]
0:
	cmp.b	#0x02,d0                         	| [cp   $02]
	jeq		0f
	rts                                    	| [ret  nz]
0:
	move.b	unknown_8D84,d0                 	| [ld   a,(unknown_8D84)]
	lea	table_419B(pc),a1                  	| [ld   de,table_419B]
	jra	indirect_jump_2D8F                 	| [jp   indirect_jump_2D8F]

table_419B:
	.long	l_41a3
	.long	l_41ac
	.long	l_41b2
	.long	l_41b8

l_41a3:
	move.b	#0x10,d0                        	| [ld   a,$10]
	cmp.b	d1,d0                            	| [cp   b]
	jeq		0f
	rts                                    	| [ret  nz]
0:
l_41a7:
	move.b	#0x03,(char_state,a2)           	| [ld   (ix+char_state),$03]
	rts                                    	| [ret]

l_41ac:
	move.b	#0xF0,d0                        	| [ld   a,$F0]
	cmp.b	d1,d0                            	| [cp   b]
	jeq		0f
	rts                                    	| [ret  nz]
0:
	jra	l_41a7                             	| [jr   $41A7]

l_41b2:
	move.b	#0x18,d0                        	| [ld   a,$18]
	cmp.b	d2,d0                            	| [cp   c]
	jeq		0f
	rts                                    	| [ret  nz]
0:
	jra	l_41a7                             	| [jr   $41A7]

l_41b8:
	move.b	#0xD8,d0                        	| [ld   a,$D8]
	cmp.b	d2,d0                            	| [cp   c]
	jeq		0f
	rts                                    	| [ret  nz]
0:
	jra	l_41a7                             	| [jr   $41A7]
	
	
set_2x2_tile_color_0C_4BC2:
	move.b	#0x0C,d0                        	| [ld   a,$0C]
set_2x2_tile_color_4BC4:
	jbsr	convert_coords_to_screen_attributes_address_4BDC	| [call convert_coords_to_screen_attributes_address_4BDC]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.b	#1,d2                           	| [inc  c]
	jbsr	convert_coords_to_screen_attributes_address_4BDC	| [call convert_coords_to_screen_attributes_address_4BDC]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.b	#1,d1                           	| [inc  b]
	jbsr	convert_coords_to_screen_attributes_address_4BDC	| [call convert_coords_to_screen_attributes_address_4BDC]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	subq.b	#1,d2                           	| [dec  c]
	jbsr	convert_coords_to_screen_attributes_address_4BDC	| [call convert_coords_to_screen_attributes_address_4BDC]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	rts                                    	| [ret]

set_2x2_tile_color_09_4BD8:
	move.b	#0x09,d0                        	| [ld   a,$09]
	jra	set_2x2_tile_color_4BC4            	| [jr   set_2x2_tile_color_4BC4]

convert_coords_to_screen_attributes_address_4BDC:
	move.w	d0,-(sp)                        	| [push af]
	jbsr	convert_coords_to_screen_address_296F	| [call convert_coords_to_screen_address_296F]
	add.w	#0x400,d6                      	| [ld   de,$0400]
										| [add  hl,de]
	move.w	(sp)+,d0                        	| [pop  af]
	rts             
	

